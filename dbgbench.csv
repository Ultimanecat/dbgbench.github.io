Bug ID,Participant ID,Fault Location 1,Fault Location 2,Fault Location 3,Fault Location 4,Fault Location 5,Provided Explanation,Provided patch,Plausibility,Correctness,Patch Category,Reason for (In)correctness,,
find.07b941b1,ZDc4NDZjMm,find/parser.c:926,find/parser.c:1644,find/parser.c:1645,,,The root cause is simple. It is an increment of the operator before its use.,"diff --git a/find/parser.c b/find/parser.c
index a087bec..e6926f4 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,8 +1641,8 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                       re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  (*arg_ptr)++;
   return true;
 }
 
",1,1,Developer Fix,N/A,,
find.07b941b1,YTA2MTE4ND,find/parser.c:1644-1645,find/parser.c:924-926,find/parser.c:924-926,,,"In find/parser.c:1644-1645 arguments pointer `arg_ptr` was accidentally incremented before using it with `estimate_pattern_match_rate` function call, and it went out of array bounds.","diff --git a/find/parser.c b/find/parser.c
index a087bec..e6926f4 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,8 +1641,8 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                      re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  (*arg_ptr)++;
   return true;
 }
",1,1,Developer Fix,N/A,,
find.07b941b1,ZTk0ZThkOD,find/parser.c:1644,find/parser.c:1644,find/parser.c:926,,,"variable pointed by arg_ptr increased before estimate_pattern_match_rate function called, this function doesn't check input","diff --git a/find/parser.c b/find/parser.c
index a087bec..e6926f4 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,8 +1641,8 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                      re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  (*arg_ptr)++;
   return true;
 }
",1,1,Developer Fix,N/A,,
find.07b941b1,OTcyZjg1Mz,find/main.c:465-466,find/tree.c:1322-1323,find/parser.c:1645-1646,find/parser.c:926-927,,The arg counter is increased before the expected position. It should be increased after calling the function estimate_pattern_match_rate() and not before as it is done,"index a087bec..e6926f4 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,8 +1641,8 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                      re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  (*arg_ptr)++;
   return true;
 }
 ",1,1,Developer Fix,N/A,,
find.07b941b1,ZmZkMWM5OG,find/parser.c:1644-1645,find/parser.c:1615,find/parser.c:926,,,"For -regex the program search for one argument.  This is done by calling parse_regex, see find/parser.c:1615. The work is then done in insert_regex() but near the end, see find/parser.c:1644-1645, there is an error. Variable arg_ptr is incremented and therefore
strpbrk in find/parser.c:926 gets NULL insted of pattern.","diff --git a/find/parser.c b/find/parser.c
index a087bec..2d4e64e 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,8 +1641,8 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                       re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  (*arg_ptr)++; /* MEOLIC: BUGX FIXING */
   return true;
 }
 
",1,1,Developer Fix,N/A,,
find.07b941b1,ZTRmYWE5Nj,find/parse.c:1644,find/parse.c:1645,find/parse.c:926,,,"strpbrk(pattern, ""."");

strpbrk function first parameter must not be NULL pointer,otherwise Segmentation Fault.","diff --git a/find/parser.c b/find/parser.c
index a087bec..30d66d7 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,7 +1641,7 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                      re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
+  /*(*arg_ptr)++;*/
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
   return true;
 }
",1,0,Regression,Fix impacts other inputs where cmd args may not be parsed at all,,
find.07b941b1,MGJmMTU1N2,find/parser.c:1640,find/parser.c:1574,find/parser.c:1648,,,"consuming the regex argument too lazily. after use of a command line parameter, the index of the current parsed argument was not incremented","diff --git a/find/parser.c b/find/parser.c
index a087bec..c1b5131 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1640,8 +1640,12 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
   error_message = re_compile_pattern (argv[*arg_ptr], strlen (argv[*arg_ptr]),
                                      re);
   if (error_message)
+  {
     error (1, 0, ""%s"", error_message);
+    return false;
+  }
   (*arg_ptr)++;
+  if(argv[*arg_ptr])
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
   return true;
 }



",1,0,Incomplete Fix,estimate_pattern_match is still called with a nullpointer,,
find.07b941b1,NDM5MjVmOT,find/parser.c:1644-1645,find/parser.c:926,find/tree.c:1322,,,"Index of array increased before using element of array it points to. Element of array must be used at find/parser.c:926 invoked from find/parser.c:1644-1645. Arguments counter must be increased after element value used. In test case used for this study, it is last argument in arguments list. That is why next vaue does not exists and segfault caused by passing NULL to a function. NULL is invalid argument for strpbrk() causing segfault. I believe if there will be more arguments in command line after -regex x, then no segfault will happen but program will not work correctly anyway. Although I did not tested that.","diff --git a/find/parser.c b/find/parser.c
index a087bec..e6926f4 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,8 +1641,8 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                      re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  (*arg_ptr)++;
   return true;
 }
",1,1,Developer Fix,N/A,,
find.07b941b1,NGU0NDRiM2,find/parser.c:1644-1645,find/parser.c:926-926,find/parser.c:1644-1645,find/parser.c:1619-1646,,Increment index too early,"diff --git a/find/parser.c b/find/parser.c
index a087bec..e6926f4 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,8 +1641,8 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                       re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  (*arg_ptr)++;
   return true;
 }
 
",1,1,Developer Fix,N/A,,
find.07b941b1,NzBjMjQ0OT,find/tree.c:1320-1322,find/parser.c:1621-1647,find/parser.c:924-935,,,"A null pointer was being passed (assuming no of arguments as 3) to estimate_pattern_match_rate.
The arg_ptr was incremented before it was sent to the above function and hence the segfaults","--- parser.c    2016-05-27 02:08:06.731991498 +0530
+++ parser_new.c    2016-05-27 02:06:20.763986442 +0530
@@ -1642,8 +1642,8 @@
   if (error_message)
     error (1, 0, ""%s"", error_message);

-  our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
   (*arg_ptr)++;
+  our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
   return true;
 }

~     ",0,1,Developer Fix,N/A,,1
find.07b941b1,NTU0ZTZlNT,find/parser.c:1621,find/tree.c:1496,find/parser.c:1644,,,"- region3:  the arg_ptr value points to a nonexistent array element already
- region1:  there's no mechanism to properly advance the arg_ptr value
- region2:  the -regex predicate maybe processed as one of the first ones leading to inefficient execution of the binary","diff --git a/find/parser.c b/find/parser.c
index a087bec..59013b0 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -489,6 +489,31 @@ estimate_timestamp_success_rate(time_t when)
   return estimate_file_age_success_rate(num_days);
 }
 
+static bool
+collect_arg_nonconst (char **argv, int *arg_ptr, char **collected_arg)
+{
+  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
+    {
+      *collected_arg = NULL;
+      return false;
+    }
+  else
+    {
+      *collected_arg = argv[*arg_ptr];
+      (*arg_ptr)++;
+      return true;
+    }
+}
+
+static bool
+collect_arg (char **argv, int *arg_ptr, const char **collected_arg)
+{
+  char *arg;
+  const bool result = collect_arg_nonconst (argv, arg_ptr, &arg);
+  *collected_arg = arg;
+  return result;
+}
+
 ^L
 /* The parsers are responsible to continue scanning ARGV for
    their arguments.  Each parser knows what is and isn't
@@ -1618,32 +1643,35 @@ parse_regex (const struct parser_table* entry, char **argv, int *arg_ptr)
 static boolean
 insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int regex_options)
 {
-  struct predicate *our_pred;
-  struct re_pattern_buffer *re;
-  const char *error_message;
-
-  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
-    return false;
-  our_pred = insert_primary_withpred (entry, pred_regex);
-  our_pred->need_stat = our_pred->need_type = false;
-  re = (struct re_pattern_buffer *)
-    xmalloc (sizeof (struct re_pattern_buffer));
-  our_pred->args.regex = re;
-  re->allocated = 100;
-  re->buffer = (unsigned char *) xmalloc (re->allocated);
-  re->fastmap = NULL;
-
-  re_set_syntax(regex_options);
-  re->syntax = regex_options;
-  re->translate = NULL;
-  
-  error_message = re_compile_pattern (argv[*arg_ptr], strlen (argv[*arg_ptr]),
-                                     re);
-  if (error_message)
-    error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
-  our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
-  return true;
+  const char *rx;
+  if (collect_arg (argv, arg_ptr, &rx))
+  {
+    struct predicate *our_pred;
+    struct re_pattern_buffer *re;
+    const char *error_message;
+
+    our_pred = insert_primary_withpred (entry, pred_regex);
+    our_pred->need_stat = our_pred->need_type = false;
+    re = (struct re_pattern_buffer *)
+      xmalloc (sizeof (struct re_pattern_buffer));
+    our_pred->args.regex = re;
+    re->allocated = 100;
+    re->buffer = (unsigned char *) xmalloc (re->allocated);
+    re->fastmap = NULL;
+
+    re_set_syntax(regex_options);
+    re->syntax = regex_options;
+    re->translate = NULL;
+    
+    error_message = re_compile_pattern (rx, strlen (rx),
+                re);
+    if (error_message)
+      error (1, 0, ""%s"", error_message);
+    //(*arg_ptr)++;
+    our_pred->est_success_rate = estimate_pattern_match_rate(rx, 1);
+    return true;
+  }
+  return false;
 }
 
 static boolean
diff --git a/find/tree.c b/find/tree.c
index 6b46962..dc48217 100644
--- a/find/tree.c
+++ b/find/tree.c
@@ -1493,6 +1493,7 @@ get_new_pred (const struct parser_table *entry)
   last_pred22->literal_control_chars = options.literal_control_chars;
   last_pred22->artificial = false;
   last_pred22->est_success_rate = 1.0;
+  last_pred22->p_cost = NeedsUnknown;
   return last_pred22;
 }
 ^L",1,1,Developer Fix,N/A,,
find.07b941b1,MzBiYjQ4ZG,find/parcer.c:1646,find/parcer.c:1640,find/parcer.c:1641,find/parcer.c:1615,,Passing pointer argument was not in correct way.,"diff --git a/find/parser.c b/find/parser.c
index a087bec..0520f10 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1618,6 +1618,7 @@ parse_regex (const struct parser_table* entry, char **argv, int *arg_ptr)
 static boolean
 insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int regex_options)
 {
+  char *temp = argv[*arg_ptr];
   struct predicate *our_pred;
   struct re_pattern_buffer *re;
   const char *error_message;
@@ -1637,12 +1638,12 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
   re->syntax = regex_options;
   re->translate = NULL;

-  error_message = re_compile_pattern (argv[*arg_ptr], strlen (argv[*arg_ptr]),
+  error_message = re_compile_pattern (temp, strlen (temp),
                                      re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
   (*arg_ptr)++;
-  our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  our_pred->est_success_rate = estimate_pattern_match_rate(temp, 1);
   return true;
 }
",1,0,Regression,Fix impacts other inputs where cmd args may not be parsed at all,,
find.07b941b1,ZTBjYWY1Nj,find/tree.c:1322,find/parser.c:1646,find/parser.c:926,,,The cause of error is trying to estimate pattern match rate with corresponding function called with incorrect pattern argument.,"diff --git a/find/parser.c b/find/parser.c
index a087bec..e6926f4 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,8 +1641,8 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                       re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  (*arg_ptr)++;
   return true;
 }
",1,1,Developer Fix,N/A,,
find.07b941b1,MTk0NjE0Mj,parser.c:1644,parser.c:1644,parser.c:1644,,,Weird premature increment of *arg_ptr at parser.c:1644. After increment it starts to point to 0 and used in estimate_pattern_match_rate().,"diff --git a/find/parser.c b/find/parser.c
index a087bec..e6926f4 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,8 +1641,8 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                      re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  (*arg_ptr)++;
   return true;
 }
 ",1,1,Developer Fix,N/A,,
find.07b941b1,ODY3ODM5YW,parser.c:926,parser.c:1643-1644,noother.c:0,,,"NULL pointer access at parser.c:926
","diff --git a/find/parser.c b/find/parser.c
index a087bec..e6926f4 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1641,8 +1641,8 @@ insert_regex (char **argv, int *arg_ptr, const struct parser_table *entry, int r
                                      re);
   if (error_message)
     error (1, 0, ""%s"", error_message);
-  (*arg_ptr)++;
   our_pred->est_success_rate = estimate_pattern_match_rate(argv[*arg_ptr], 1);
+  (*arg_ptr)++;
   return true;
 }
 
",1,1,Developer Fix,N/A,,
find.091557f6,ZTk0ZThkOD,find/pred.c:1578,find/pred.c:305-315,find/ftsfind.c:229-248,find/util.c:228-236,,"because ""stat"" function never called on symlinks, because of predicate->need_stat member wrongly initialized with false;","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..c1b0b84 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -237,6 +237,7 @@ visit(FTS *p, FTSENT *ent, struct stat *pstat)

   /* Apply the predicates to this path. */
   eval_tree = get_eval_tree();
+  eval_tree->need_stat = following_links();
   (*(eval_tree)->pred_func)(ent->fts_path, pstat, eval_tree);

   /* Deal with any side effects of applying the predicates. */",0,0,Incomplete Fix,Test case still fails,,
find.091557f6,YTA2MTE4ND,find/pred.c:1577-1578,find/ftsfind.c:457-460,find/ftsfind.c:465,gnulib/lib/fts.c:1384-1394,,"The error is inconsistency between state.have_type and state.type values. The first beeing true supposes the second is non-zero

The inconsistency was caused at find/ftsfind.c:457-460 and detected at find/pred.c:1577-1578

The actual reason behind this inconsistency is that fts_read doesn't return proper status code at gnulib/lib/fts.c:1384-1394","diff --git a/gnulib/lib/fts.c b/gnulib/lib/fts.c
index 1b5384b..a22072f 100644
--- a/gnulib/lib/fts.c
+++ b/gnulib/lib/fts.c
@@ -1384,7 +1384,7 @@ fts_stat(FTS *sp, register FTSENT *p, bool follow)
        if (ISSET(FTS_LOGICAL) || follow) {
                if (stat(p->fts_accpath, sbp)) {
                        saved_errno = errno;
-                       if (errno == ENOENT
+                       if (errno == ELOOP
                            && lstat(p->fts_accpath, sbp) == 0) {
                                __set_errno (0);
                                return (FTS_SLNONE);
",1,1,Different but Correct Fix,"a) we did not specify that no error should be shown, b) in another version this is handled as error.",,
find.091557f6,OTcyZjg1Mz,find/ftsfind.c:557-605,find/ftsfind.c:391-476,find/ftsfind.c:613-632,,,"Not treated all returned error codes from a function. This error is similar to other already done. 

The fts_open() function invoked at section can return a range of values, some of them error conditions that were not checked at section 2 (function consider_visiting()). Skipping this checking, exactly for the value FTS_NS that it is an error condition, caused that the code treated this as an OK scenario and then crashed","--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -412,7 +412,6 @@ consider_visiting(FTS *p, FTSENT *ent)
     }
   inside_dir(p->fts_cwd_fd);
   prev_depth = ent->fts_level;
-
   
   /* Cope with various error conditions. */
   if (ent->fts_info == FTS_ERR
@@ -428,7 +427,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       error_severity(1);
       return;
     }
-  else if (ent->fts_info == FTS_SLNONE)
+  else if (ent->fts_info == FTS_SLNONE) 
     {
       /* fts_read() claims that ent->fts_accpath is a broken symbolic
        * link.  That would be fine, but if this is part of a symbolic
@@ -443,6 +442,18 @@ consider_visiting(FTS *p, FTSENT *ent)
          error_severity(1);
          return;
        }
+
+    }
+    else if (ent->fts_info == FTS_NS)
+    {
+      state.type = mode = 0;
+
+      if (symlink_loop(ent->fts_accpath))
+      {
+        error(0, ELOOP, ent->fts_path);
+        error_severity(1);
+        return;
+      }
     }
   ",1,1,Different but Correct Fix,"a) we did not specify that no error should be shown, b) in another version this is handled as error.",,
find.091557f6,ZmZkMWM5OG,find/pred.c:1578,find/ftsfind.c:584,find/ftsfind.c:430-444,,,"The illegal situation on filesystem has been forgotten to catch. 
For symbolic links loop, fts_read() will return an empty ent and ent->fts == FTS_NS, see  find/ftsfind.c:584. There is a function symlink_loop() which should check and report this situation but it is not called, because ent->fts_info is not FTS_SLNONE but FTS_NS, see find/ftsfind.c:430-444.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..3ce3077 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -428,7 +428,8 @@ consider_visiting(FTS *p, FTSENT *ent)
       error_severity(1);
       return;
     }
-  else if (ent->fts_info == FTS_SLNONE)
+  else if (ent->fts_info == FTS_SLNONE
+           || ent->fts_info == FTS_NS) /* MEOLIC: BUG FIXING */
     {
       /* fts_read() claims that ent->fts_accpath is a broken symbolic
        * link.  That would be fine, but if this is part of a symbolic
@@ -442,7 +443,13 @@ consider_visiting(FTS *p, FTSENT *ent)
           error(0, ELOOP, ent->fts_path);
           error_severity(1);
           return;
+    /* MEOLIC: BUG FIXING */
+        } else {
+      error(0, ent->fts_errno, ent->fts_path);
+      error_severity(1);
+      return;
         }
+        /* MEOLIC: END OF FIX */
     }
   
   /* Not an error, cope with the usual cases. */
",1,1,Different but Correct Fix,"a) we did not specify that no error should be shown, b) in another version this is handled as error.",,
find.091557f6,MGJmMTU1N2,find/util.c:219,find/util.c:237,find/pred.c:313,,,"condition for getting stat on file was too tight, it should have been: if file is special type and mode is not known","diff --git a/find/util.c b/find/util.c
index 46e6455..33def97 100644
--- a/find/util.c
+++ b/find/util.c
@@ -227,7 +227,7 @@ get_info (const char *pathname,
    */
   if (pred_ptr->need_stat)
     todo = true;
-  else if ((pred_ptr->need_type && (0 == state.have_type)))
+  else if ((pred_ptr->need_type && ( (0 == state.have_type) || (p->st_mode==0)  ) ))
     todo = true;

   if (todo)
",1,0,Incorrect workaround,stat() is not supposed to be called,,
find.091557f6,ZTRmYWE5Nj,find/pred.c:1578,find/ftsfind.c:460,find/ftsfind.c:1166,,,state type not correct,"diff --git a/find/pred.c b/find/pred.c
index 205dd94..f27990b 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -1575,7 +1575,7 @@ pred_type (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
   mode_t type = pred_ptr->args.type;

   assert(state.have_type);
-  assert(state.type != 0);
+/*  assert(state.type != 0);*/

   (void) pathname;
",1,0,Treating Symptom,,,
find.091557f6,NDM5MjVmOT,find/pred.c:1578,find/ftsfind.c:389-515,lib/fts.h:204,,,Assert condition failed (find/pred.c:1578). Error state (gnulib/lib/fts_.h:204) caused by valid reason but seems do not handled properly before this point. ,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..773531b 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -416,6 +416,7 @@ consider_visiting(FTS *p, FTSENT *ent)
   
   /* Cope with various error conditions. */
   if (ent->fts_info == FTS_ERR
+      || FTS_NS == ent->fts_info
       || ent->fts_info == FTS_DNR)
     {
       error(0, ent->fts_errno, ent->fts_path);",1,1,Different but Correct Fix,"a) we did not specify that no error should be shown, b) in another version this is handled as error.",,
find.091557f6,NGU0NDRiM2,ftsfind.c:425-430,ftsfind.c:425-430,ftsfind.c:431-446,pred.c:1578-1578,,Did not handle FTS_NS value of ent->fts_info.,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..8454a37 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -444,6 +444,15 @@ consider_visiting(FTS *p, FTSENT *ent)
           return;
         }
     }
+  else if(ent->fts_info == FTS_NS)
+  {
+      if(symlink_loop(ent->fts_accpath))
+      {
+          error(0, ELOOP, ent->fts_path);
+          error_severity(1);
+          return;
+      }
+  }
   
   /* Not an error, cope with the usual cases. */
   if (ent->fts_info == FTS_NSOK)
",1,1,Different but Correct Fix,"a) we did not specify that no error should be shown, b) in another version this is handled as error.",,
find.091557f6,NzBjMjQ0OT,find/ftsfind.c:240-241,find/pred.c:306-308,find/pred.c:1577-1579,,,find aborts the file if the mode is 0000,"--- pred.c  2016-05-29 02:28:02.102990540 +0530
+++ pred_new.c  2016-05-29 02:29:15.158994025 +0530
@@ -1575,8 +1575,9 @@
   mode_t type = pred_ptr->args.type;

   assert(state.have_type);
-  assert(state.type != 0);
-
+  if (0 == state.type)
+      return false;
+  
   (void) pathname;

   if (state.have_stat)
",1,0,Treating Symptom,,,
find.091557f6,ZTBjYWY1Nj,find/ftsfind.c:515,find/ftsfind.c:243,find/pred.c:1578,,,The case of symlink loop is not processed correctly; it should print an error message instead of plain assert,"diff --git a/find/pred.c b/find/pred.c
index 205dd94..a86be3b 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -1575,7 +1575,8 @@ pred_type (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
   mode_t type = pred_ptr->args.type;
 
   assert(state.have_type);
-  assert(state.type != 0);
+  if (state.type == 0)  
+    error (0, errno, ""`%s'"", pathname);
   
   (void) pathname;
",1,0,Treating Symptom,,,
find.091557f6,MzBiYjQ4ZG,find/pred.c:1578,find/pred.c:1610,find/ftsfind.c:560,,,method of checking variable was wrong.  Function should return some value but it was not returning it was just checking using assert but it should be if.,"diff --git a/find/pred.c b/find/pred.c
index 205dd94..a2e0808 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -1575,7 +1575,10 @@ pred_type (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
   mode_t type = pred_ptr->args.type;

   assert(state.have_type);
-  assert(state.type != 0);
+  if (0 == state.type)
+    {
+      return false;
+    }

   (void) pathname;

",1,0,Treating Symptom,,,
find.091557f6,MTk0NjE0Mj,ftsfind.c:440,ftsfind.c:455,ftsfind.c:460,,,"fts_read() returns FTS_NS in ent->fts_info which is not handled in consider_visiting() (ftsfind.c:455) and thus state.type left intact as 0 (ftsfind.c:460)  and triggering assert later in pred_type().
I noticed the symlink_loop() at ftsfind.c:440 which apparently should be used in case of, well, symlink loop.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..6ef1a4c 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -428,7 +428,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       error_severity(1);
       return;
     }
-  else if (ent->fts_info == FTS_SLNONE)
+  else if (ent->fts_info == FTS_SLNONE || ent->fts_errno == ELOOP)
     {
       /* fts_read() claims that ent->fts_accpath is a broken symbolic
        * link.  That would be fine, but if this is part of a symbolic
",1,1,Different but Correct Fix,"a) we did not specify that no error should be shown, b) in another version this is handled as error.",,
find.091557f6,ODY3ODM5YW,pred.c:1577-1578,ftsfind.c:442-444,fts.h:203,ftsfind.c:458,,Unchecked error condition. Fetching the stat might fail,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..cbe8266 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -444,6 +444,9 @@ consider_visiting(FTS *p, FTSENT *ent)
          return;
        }
     }
+  else if (ent->fts_info == FTS_NS) {
+    return;
+  }
   
   /* Not an error, cope with the usual cases. */
   if (ent->fts_info == FTS_NSOK)
",1,1,Different but Correct Fix,"a) we did not specify that no error should be shown, b) in another version this is handled as error.",,
find.183115d0,YTA2MTE4ND,pred.c:516-525,pred.c:528-555,pred.c:566,pred.c:571,,Directory descriptor is never closed,"diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..5713f66 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -657,6 +657,12 @@ impl_pred_exec (const char *pathname,
          result = false;
        }
     }
+
+  if (local)
+    {
+      close(execp->wd_for_exec->desc);
+    }
+
   if (target != pathname)
     {
       assert (local);
",1,1,Developer-Fix,N/A,,
find.183115d0,ZTk0ZThkOD,find/pred.c:520,find/pred.c:531-554,find/find.c:571-598,find/find.c:611-668,,"find/pred.c:520 - directory actually opened;
find/find.c:611-668 - after exec called on directory, it never closed
","diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..80fc35b 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -662,6 +662,9 @@ impl_pred_exec (const char *pathname,
       assert (local);
       free (target);
     }
+
+  if (local)
+         free_cwd(execp->wd_for_exec);
   return result;
 }
",1,1,Developer-Fix,N/A,,
find.183115d0,ZmZkMWM5OG,find/pred.c:520,find/pred.c:523,find/pred.c:660-664,find/ftsfind.c:349-356,,"For execdir, openat is called for every entry, see find/pred.c:520. The error appears because there is no coresponding close. There is a call to set_cloexec_flag() in find/pred.c:523 but I do not really understand the meaning of this flag and it is apparently not enough to prevent the error. fd remains open at the end of impl_pred_exec(), I have made check in find/pred.c:660-664. Probably, fd must be closed there. Or, something must be changed so that fd will be closed in find/ftsfind.c:349-356, that lines are called after all elements but those if statements are false during the problematic run.","diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..7078422 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -661,6 +661,7 @@ impl_pred_exec (const char *pathname,
     {
       assert (local);
       free (target);
+      close(execp->wd_for_exec->desc); /* MEOLIC: FIXING BUG */
     }
   return result;
 }
",1,1,Developer-Fix,N/A,,
find.183115d0,MGJmMTU1N2,find/pred.c:657,find/pred.c:550,find/pred.c:2074,,,file descriptor for opening working dir was not closed after child exited.,"diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..6a02c9d 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -657,6 +657,7 @@ impl_pred_exec (const char *pathname,
          result = false;
        }
     }
+  close(execp->wd_for_exec->desc);
   if (target != pathname)
     {
       assert (local);

",1,1,Developer-Fix,N/A,,
find.183115d0,NDM5MjVmOT,find/pred.c:579,find/pred.c:520,find/pred.c:559-666,,,"Program opens directory file for each execdir call (find/pred.c:520) but do not closes fd. Although FD_CLOEXEC flag is set, but file descriptor is opened before fork() and child's exec(). Parent process has this descriptor not closed within impl_pred_exec() (find/pred.c:559-666). Finally, program consumes all file descriptors it limited to and failed at find/pred.c:579.","diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..91130f7 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -645,6 +645,12 @@ impl_pred_exec (const char *pathname,
 
       /* Actually invoke the command. */
       bc_do_exec (&execp->ctl, &execp->state);
+      if (execp->wd_for_exec && execp->wd_for_exec != initial_wd)
+        {
+          close (execp->wd_for_exec->desc);
+          free (execp->wd_for_exec);
+          execp->wd_for_exec = NULL;
+        }
       if (WIFEXITED(execp->last_child_status))
         {
           if (0 == WEXITSTATUS(execp->last_child_status))",1,1,Different but Correct Fix,Maybe a bit inefficient (double close),,
find.183115d0,NGU0NDRiM2,pred.c:516-525,pred.c:558-665,pred.c:577-577,,,"Resources allocated for execp->wd_for_exec, but do not freed.","diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..6905f2c 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -656,6 +656,10 @@ impl_pred_exec (const char *pathname,
         {
           result = false;
         }
+      if (local)
+      {
+         free_cwd(execp->wd_for_exec);
+      }
     }
   if (target != pathname)
     {
",1,1,Developer-Fix,N/A,,
find.183115d0,NTU0ZTZlNT,find/pred.c:519,find/pred.c:659,find/pred.c:665,,,"The exec working directories of the predicates' ""exec_vec""s are never freed resulting to the leak on the directories.  These directories' file descriptors aren't closed also resulting to the later ""execdir""s not executing anymore.","diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..e6da63d 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -656,12 +656,21 @@ impl_pred_exec (const char *pathname,
        {
          result = false;
        }
+       if(execp->wd_for_exec)
+       {
+         close(execp->wd_for_exec->desc);
+       }
     }
   if (target != pathname)
     {
       assert (local);
       free (target);
     }
+  if(execp->wd_for_exec)
+  {
+    free(execp->wd_for_exec);
+    execp->wd_for_exec = NULL;
+  }
   return result;
 }",1,1,Different but Correct Fix,N/A,,
find.183115d0,NzBjMjQ0OT,find/pred.c:580-582,find/pred.c:554-556,find/pred.c:518-528,,,the execp->wd_for_exec->desc fd were not getting closed and hence the problem,"--- pred.c  2016-05-29 01:47:08.506873490 +0530
+++ pred_new.c  2016-05-29 01:47:56.462875778 +0530
@@ -666,6 +666,8 @@
       assert (local);
       free (target);
     }
+
+  close(execp->wd_for_exec->desc);
   return result;
 }
",1,1,Different but Correct Fix,Maybe a bit inefficient (double close),,
find.183115d0,ZTBjYWY1Nj,find/pred.c:579,find/pred.c:545,find/pred.c:520,,,"The file descriptor for working directory for -execdir predicate was opened (region 3), but never was closed, which led to descriptor leak.","diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..d2071c1 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -662,6 +662,9 @@ impl_pred_exec (const char *pathname,
       assert (local);
       free (target);
     }
+
+  close(execp->wd_for_exec->desc);
+
   return result;
 }
 ",1,1,Different but Correct Fix,Maybe a bit inefficient (double close),,
find.183115d0,MzBiYjQ4ZG,find/pred.c:580,find/pred.c:530,find/pred.c:664,,,"As we have limited maximum open file, it was not taken care in code. code was keeping all working directory open which was impacting limitation.","diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..ea99ee9 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -661,6 +661,8 @@ impl_pred_exec (const char *pathname,
     {
       assert (local);
       free (target);
+      // lets free the working directory as well as it is not necessory now
+      free_cwd (execp->wd_for_exec);
     }
   return result;
 }
",1,1,Developer-Fix,N/A,,
find.183115d0,MTk0NjE0Mj,pred.c:2073,pred.c:520,pred.c:2097,,,"execp->wd_for_exec->desc (pred.c:520) is not closed after exec() in launch() pred.c:2073 . Apparently, FD_CLOEXEC does not work. Or I do not understand how it should work.","diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..4b2cea6 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -2127,6 +2127,10 @@ launch (struct buildcmd_control *ctl, void *usercontext, int argc, char **argv)
        }
     }
 
+  close(execp->wd_for_exec->desc);
+  free(execp->wd_for_exec);
+  execp->wd_for_exec = NULL;
+
   if (WIFSIGNALED (execp->last_child_status))
     {
       error (0, 0, _(""%s terminated by signal %d""),
",1,0,Incomplete Fix,N/A,,
find.183115d0,ODY3ODM5YW,pred.c:520,pred.c:531-545,pred.c:577,,,"At pred.c:577  record_exec_dir is called. This functions checks the todo flag. This seems to be wrong since we should actually check whether the execp is actually initialised. Thus, the wd is initialised multiple times.Initialising the wd opens it. It is never closed. We run out of fds.","diff --git a/find/pred.c b/find/pred.c
index 3acfe9f..aeb26c3 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -517,6 +517,8 @@ initialise_wd_for_exec (struct exec_val *execp, int cwd_fd, const char *dir)
 {
   execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));
   execp->wd_for_exec->name = NULL;
+  if (execp->wd_for_exec->desc >= 0)
+    close(execp->wd_for_exec->desc);
   execp->wd_for_exec->desc = openat (cwd_fd, dir, O_RDONLY);
   if (execp->wd_for_exec->desc < 0)
     return false;
",1,0,Incomplete Fix,"Still, does not close all descriptors",,
find.24bf33c0,ZTk0ZThkOD,find/util.c:228,find/pred.c:310,find/pred.c:240,,,"""stat"" function doesn't get called on the path inside broken symlink","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..9d11488 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -231,12 +231,13 @@ visit(FTS *p, FTSENT *ent, struct stat *pstat)
   struct predicate *eval_tree;

   state.curdepth = ent->fts_level;
-  state.have_stat = (ent->fts_info != FTS_NS) && (ent->fts_info != FTS_NSOK);
+  state.have_stat = (ent->fts_info != FTS_NS) && (ent->fts_info != FTS_NSOK) /*&& (ent->fts_info != FTS_SLNONE)*/;
   state.rel_pathname = ent->fts_accpath;
   state.cwd_dir_fd   = p->fts_cwd_fd;

   /* Apply the predicates to this path. */
   eval_tree = get_eval_tree();
+  eval_tree->need_stat = !state.have_stat;
   (*(eval_tree)->pred_func)(ent->fts_path, pstat, eval_tree);

   /* Deal with any side effects of applying the predicates. */
@@ -589,6 +590,7 @@ find(char *arg)
          state.have_type = false;
          state.type = 0;
          consider_visiting(p, ent);
+
        }
       fts_close(p);
       p = NULL;
",0,0,Incomplete Fix,Test case still fails,,
find.24bf33c0,YTA2MTE4ND,find/ftsfind.c:388-462,find/ftsfind.c:578-596,find/ftsfind.c:418,,,error condition check at find/ftsfind.c:418 ignores one of the possible error codes,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..310d5ab 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -416,6 +416,7 @@ consider_visiting(FTS *p, FTSENT *ent)
   
   /* Cope with various error conditions. */
   if (ent->fts_info == FTS_ERR
+      || ent->fts_info == FTS_NS
       || ent->fts_info == FTS_DNR)
     {
       error(0, ent->fts_errno, ent->fts_path);
",1,0,Regression,Fix also impacts inputs where FTS_NS is not an error flag,,
find.24bf33c0,OTcyZjg1Mz,find/ftsfind.c:668-702,find/ftsfind.c:600-608,find/ftsfind.c:548-591,find/ftsfind.c:391-540,,An non existing file is treated as a valid path and returned error is ignored,"--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -428,7 +428,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       error_severity(1);
       return;
     }
-  else if (ent->fts_info == FTS_SLNONE)
+  else if ((ent->fts_info == FTS_SLNONE) ||(ent->fts_info == FTS_NS))
     {
       /* fts_read() claims that ent->fts_accpath is a broken symbolic
        * link.  That would be fine, but if this is part of a symbolic",1,1,Developer Fix,N/A,,
find.24bf33c0,ZmZkMWM5OG,find/ftsfind.c:431-446,find/ftsfind.c:586,pred.c:1459,,,"For symbolic links loops fts_read() at find/ftsfind.c:586 returns ent with ent->fts_info == FTS_NS. This situation is not covered in consider_visiting(), e.g. in find/ftsfind.c:431-446. Thus the program proceeds further without the error and line in pred.c:1459 it prints out the element.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..178b937 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -428,7 +428,8 @@ consider_visiting(FTS *p, FTSENT *ent)
       error_severity(1);
       return;
     }
-  else if (ent->fts_info == FTS_SLNONE)
+  else if (ent->fts_info == FTS_SLNONE
+           || ent->fts_info == FTS_NS) /* MEOLIC: BUG FIXING */
     {
       /* fts_read() claims that ent->fts_accpath is a broken symbolic
        * link.  That would be fine, but if this is part of a symbolic
@@ -442,6 +443,12 @@ consider_visiting(FTS *p, FTSENT *ent)
           error(0, ELOOP, ent->fts_path);
           error_severity(1);
           return;
+    /* MEOLIC: BUG FIXING */
+        } else {
+      error(0, ent->fts_errno, ent->fts_path);
+      error_severity(1);
+      return;
+    /* MEOLIC: END OF FIX */
         }
     }
   
",1,0,Regression,Fix also impacts unrelated flags,,
find.24bf33c0,MGJmMTU1N2,find/ftsfind.c:546,find/ftsfind.c:580,find/ftsfind.c:590,,,an error case when the top dir could not be opened was ignored,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..3e6b7b7 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -581,6 +581,10 @@ find(char *arg)
             _(""cannot search %s""),
             quotearg_n_style(0, locale_quoting_style, arg));
     }
+    else if(p->fts_cwd_fd<0) {
+      error (0, errno,quotearg_n_style(0, locale_quoting_style, arg));
+      state.exit_status=p->fts_cwd_fd;
+    }
   else
     {
       while ( (ent=fts_read(p)) != NULL )
",1,0,Regression,Unrelated,,
find.24bf33c0,ZTRmYWE5Nj,find/ftsfind.c:440-445,find/ftsfind.c:318-327,find/ftsfind.c:413-414,,,"""fts_info"" is not the right value","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..81ee7ee 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -413,7 +413,7 @@ consider_visiting(FTS *p, FTSENT *ent)
   inside_dir(p->fts_cwd_fd);
   prev_depth = ent->fts_level;

-
+  ent->fts_info = FTS_SLNONE;
   /* Cope with various error conditions. */
   if (ent->fts_info == FTS_ERR
       || ent->fts_info == FTS_DNR)
",0,0,Incomplete Fix,Test case still fails,,
find.24bf33c0,NDM5MjVmOT,gnulib/lib/fts.c:1385,find/ftsfind.c:578,find/ftsfind.c:389-542,,,"Program trying to open given path for search by invoking  fts_open() (find/ftsfind.c:578). On error conditions it set fields of returned structure (fts_info, fts_errno) appropriately (gnulib/lib/fts.c:1385). If fts_open() can not stat() given path, it returns FTS_NS - 'stat(2) failed' value in fts_info field. But this value do not checked in consider_visiting() function  (find/ftsfind.c:389-542) like other errors. That is why some error cases remains not reported just working like there are no error at all.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..773531b 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -416,6 +416,7 @@ consider_visiting(FTS *p, FTSENT *ent)
   
   /* Cope with various error conditions. */
   if (ent->fts_info == FTS_ERR
+      || FTS_NS == ent->fts_info
       || ent->fts_info == FTS_DNR)
     {
       error(0, ent->fts_errno, ent->fts_path);
",1,0,Regression,Fix also impacts inputs where FTS_NS is not an error flag,,
find.24bf33c0,NGU0NDRiM2,ftsfind.c:431-446,ftsfind.c:389-541,ftsfind.c:389-541,,,Do not handle FTS_NS value of ent->fts_info.,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..5895bf6 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -444,7 +444,16 @@ consider_visiting(FTS *p, FTSENT *ent)
           return;
         }
     }
-  
+  else if (ent->fts_info == FTS_NS)
+  {
+      if (symlink_loop(ent->fts_accpath))
+      {
+         error(0, ELOOP, ent->fts_path);
+         error_severity(1);
+         return;
+      }
+  }
+
   /* Not an error, cope with the usual cases. */
   if (ent->fts_info == FTS_NSOK)
     {
",1,0,Regression,There is no problem with negative file descriptors,,
find.24bf33c0,NTU0ZTZlNT,find/ftsfind.c:447,find/ftsfind.c:545,find/ftsfind.c:694-699,,,"- region 1:  The code lacks the handler when the flags member of the consider_visiting FTSENT* argument is a stat(2) failure.
- region 2:  continued read of member files & directories of directories that produced an errno makes these kinds of 'finds' inefficient
- region 3:  catering for negative file descriptors adds a computing cycle","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..a38acd0 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -444,6 +444,19 @@ consider_visiting(FTS *p, FTSENT *ent)
          return;
        }
     }
+  else if (ent->fts_info == FTS_NS)
+    {
+    if (ent->fts_level)
+  {
+    if (symlink_loop (ent->fts_accpath))
+      {
+        error(0, ELOOP, ent->fts_path);
+        error_severity(1);
+        return;
+      }
+
+  }
+    }
   
   /* Not an error, cope with the usual cases. */
  if (ent->fts_info == FTS_NSOK)
@@ -542,7 +555,7 @@ consider_visiting(FTS *p, FTSENT *ent)
 
 
 ^L
-static void
+static bool
 find(char *arg)
 {
   char * arglist[2];
@@ -590,9 +603,18 @@ find(char *arg)
          state.type = 0;
          consider_visiting(p, ent);
        }
+      if (errno)
+  {
+    error (0, errno,
+     ""failed to read file names from file system at or below the directory"");
+    error_severity (1);
+    return false;
+  }
+
       fts_close(p);
      p = NULL;
     }
+  return true;
 }
 
 
@@ -605,7 +627,10 @@ process_all_startpoints(int argc, char *argv[])
   for (i = 0; i < argc && !looks_like_expression(argv[i], true); i++)
     {
       state.starting_path_length = strlen(argv[i]); /* TODO: is this redundant? */
-      find(argv[i]);
+      if (!find (argv[i]))
+      {
+        return false;
+      }
     }
 
   if (i == 0)
@@ -691,12 +716,6 @@ main (int argc, char **argv)
       close (starting_desc);
       starting_desc = -1;
     }
-  if (starting_desc < 0)
-    {
-      starting_dir = xgetcwd ();
-      if (! starting_dir)
-       error (1, errno, _(""cannot get current directory""));
-    }
 
 
   process_all_startpoints(argc-end_of_leading_options, argv+end_of_leading_options);",1,1,Developer-Fix,N/A,,
find.24bf33c0,NzBjMjQ0OT,find/ftsfind.c:687-689,find/ftsfind.c:614-615,find/ftsfind.c:388-469,,,"The line numbers might not be accurate since I have applied the patch and then put these numbers.
The condition to check the failure of stat call was missing. I added a simple check","--- ftsfind.c   2016-05-28 02:11:12.950418832 +0530
+++ ftsfind_new.c   2016-05-28 02:13:58.974426753 +0530
@@ -429,6 +429,28 @@
       return;
     }

+  else if (ent->fts_info == FTS_NS)
+    {
+      if (ent->fts_level == 0)
+    {
+      error(0, ent->fts_errno, ""%s"",
+        quotearg_n_style(0,locale_quoting_style, ent->fts_path));
+      error_severity(1);   
+      return;
+    }
+      else
+    {
+      if (symlink_loop(ent->fts_accpath))
+        {
+          error(0, ELOOP, ""%s"",
+            quotearg_n_style(0,locale_quoting_style, ent->fts_path));
+          error_severity(1);
+          return;
+        }
+    }
+    }
+
+
   else if (ent->fts_info == FTS_SLNONE)
     {
       /* fts_read() claims that ent->fts_accpath is a broken symbolic
",1,1,Developer-Fix,N/A,,
find.24bf33c0,MzBiYjQ4ZG,find/ftsfind.c:431,find/ftsfind.c:440,find/ftsfind.c:318,,,not taking care of all return types.,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..edef5c1 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -428,7 +428,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       error_severity(1);
       return;
     }
-  else if (ent->fts_info == FTS_SLNONE)
+  else if (ent->fts_info == FTS_SLNONE || ent->fts_info == FTS_NS)
     {
       /* fts_read() claims that ent->fts_accpath is a broken symbolic
        * link.  That would be fine, but if this is part of a symbolic
",1,1,Developer-Fix,N/A,,
find.24bf33c0,ZTBjYWY1Nj,find/ftsfind.c:431,find/ftsfind.c:318,find/ftsfind.c:457,,,The check for symlink loop (region 2) was not executed because of testing against incomplete set of flags in region 1; for symlink loop the case is that ent->fts_info = FTS_NS. So the processing was going further (region 3) like it was normal file.,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..edef5c1 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -428,7 +428,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       error_severity(1);
       return;
     }
-  else if (ent->fts_info == FTS_SLNONE)
+  else if (ent->fts_info == FTS_SLNONE || ent->fts_info == FTS_NS)
     {
       /* fts_read() claims that ent->fts_accpath is a broken symbolic
        * link.  That would be fine, but if this is part of a symbolic
",1,1,Developer-Fix,N/A,,
find.24bf33c0,MTk0NjE0Mj,ftsfind.c:431,ftsfind.c:431,ftsfind.c:431,,,"Basically the same bug as in find.091557f6.
","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..6ef1a4c 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -428,7 +428,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       error_severity(1);
       return;
     }
-  else if (ent->fts_info == FTS_SLNONE)
+  else if (ent->fts_info == FTS_SLNONE || ent->fts_errno == ELOOP)
     {
       /* fts_read() claims that ent->fts_accpath is a broken symbolic
        * link.  That would be fine, but if this is part of a symbolic
",1,1,Developer-Fix,N/A,,
find.24bf33c0,ODY3ODM5YW,find.c:431,noother.c:0,noother.c:0,,,FTS_NS is not handled,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 3e94da1..d2bfa80 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -428,7 +428,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       error_severity(1);
       return;
     }
-  else if (ent->fts_info == FTS_SLNONE)
+  else if (ent->fts_info == FTS_SLNONE || ent->fts_info == FTS_NS)
     {
       /* fts_read() claims that ent->fts_accpath is a broken symbolic
        * link.  That would be fine, but if this is part of a symbolic
",1,1,Developer-Fix,N/A,,
find.24e2271e,ZDc4NDZjMm,find/pred.c:580,find/pred.c:712,find/ftsfind.c:278,,,"The state.starting_path_length variable does not change once it has been set. Hence, it continues using the value of the very first segment. This logic requires to be checked to fix the issue.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..4314d45 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -275,7 +275,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       mode = statbuf.st_mode;
     }
 
-  if (0 == ent->fts_level && (0u == state.starting_path_length))
+  if (0 == ent->fts_level)
     state.starting_path_length = ent->fts_pathlen;
               
   if (0 != digest_mode(mode, ent->fts_path, ent->fts_name, &statbuf, 0))
",1,1,Different but Correct,N/A,,
find.24e2271e,YTA2MTE4ND,find/pred.c:709-718,find/ftsfind.c:279,find/ftsfind.c:278,,,state.starting_path_length is used in pred_fprintf at find/pred.c:709-718 and it is not changed after switching to second starting point,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..4314d45 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -275,7 +275,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       mode = statbuf.st_mode;
     }
 
-  if (0 == ent->fts_level && (0u == state.starting_path_length))
+  if (0 == ent->fts_level)
     state.starting_path_length = ent->fts_pathlen;
              
   if (0 != digest_mode(mode, ent->fts_path, ent->fts_name, &statbuf, 0))
",1,1,Different but Correct,N/A,,
find.24e2271e,OTcyZjg1Mz,find/ftsfind.c:125-136,find/pred.c:709-718,find/pred.c:809-820,find/ftsfind.c:278-280,,"At sections 2 and 3 we receive always the same length value regardless of the directory being considered (always 4 value in this case that is the length of the first directory treated). This value is never updated for other directories and this is the buggy part.
This was done at section 4","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..4314d45 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -275,7 +275,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       mode = statbuf.st_mode;
     }
 
-  if (0 == ent->fts_level && (0u == state.starting_path_length))
+  if (0 == ent->fts_level /* && (0u == state.starting_path_length)*/)
     state.starting_path_length = ent->fts_pathlen;
              
   if (0 != digest_mode(mode, ent->fts_path, ent->fts_name, &statbuf, 0))",1,1,Different but Correct,N/A,,
find.24e2271e,ZmZkMWM5OG,find/ftsfind.c:278,find/pred.c:714,find/pred.c:813,,,"Condition in find/ftsfind.c:278 is not correct. The second part, i.e. (0u == state.starting_path_length) is wrong and thus starting_path_length is updated only the first time. It is used in find/pred.c:714 and find/pred.c:813 and we get wrong results.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..e40581e 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -275,7 +275,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       mode = statbuf.st_mode;
     }
 
-  if (0 == ent->fts_level && (0u == state.starting_path_length))
+  if (0 == ent->fts_level) /* MEOLIC: BUG FIXING */
     state.starting_path_length = ent->fts_pathlen;
               
   if (0 != digest_mode(mode, ent->fts_path, ent->fts_name, &statbuf, 0))
",1,1,Different but Correct,N/A,,
find.24e2271e,ZTRmYWE5Nj,find/ftsfind.c:279-280,find/ftsfind.c:273-276,find/ftsfind.c:375-378,,,"""starting_path_length"" variable need to reset every directory.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..229e18e 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -273,6 +273,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       state.have_stat = true;
       statbuf = *(ent->fts_statp);
       mode = statbuf.st_mode;
+      state.starting_path_length = 0u;
     }
",1,0,Incomplete Fix,Only when mode is not 0,,
find.24e2271e,NDM5MjVmOT,find/pred.c:712-717,ftsfind.c:278-279,find/pred.c:813,,,Directory part length conditionally set to state.starting_path_length structure (ftsfind.c:278-279). Condition requires that previous value must be 0u but this structure entry does not either zeroed or assigned new value after first use. So for each usage of that directory entry used incorrect path length value.,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..4314d45 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -275,7 +275,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       mode = statbuf.st_mode;
     }
 
-  if (0 == ent->fts_level && (0u == state.starting_path_length))
+  if (0 == ent->fts_level)
     state.starting_path_length = ent->fts_pathlen;
               
   if (0 != digest_mode(mode, ent->fts_path, ent->fts_name, &statbuf, 0))",1,1,Different but Correct,N/A,,
find.24e2271e,NGU0NDRiM2,find/pred.c:588-597,find/pred.c:719-728,find/pred.c:819-830,,,"Did not count state.starting_path_length, and in find/pred.c:719-728 (case 'H') program setup 0 character to pathname (pathname[state.starting_path_length] = '\0';)","diff --git a/find/pred.c b/find/pred.c
index ec8e94a..91d7b9b 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -585,6 +585,16 @@ pred_fprintf (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
   char *cp;
   char hbuf[LONGEST_HUMAN_READABLE + 1];
 
+  const char *delimitter = strchr(pathname, '/');
+  if(delimitter)
+  {
+          state.starting_path_length = delimitter - pathname;
+  }
+  else
+  {
+          state.starting_path_length = strlen (pathname);
+  }
+
   for (segment = pred_ptr->args.printf_vec.segment; segment;
        segment = segment->next)
     {
",0,0,Regression,Regression test fails,,
find.24e2271e,NzBjMjQ0OT,find/ftsfind.c:687-689,find/ftsfind.c:383-405,find/ftsfind.c:374-376,find/ftsfind.c:277-280,,The problem was when a call to find() is made (find(argv[i]) in process_all_startpoints()) the state.starting_path_length was getting overwritten with the length of the current argument. Therefore I initialized the starting_path_length before find(),"--- ftsfind.c   2016-05-27 22:43:13.714627914 +0530
+++ ftsfind_new.c   2016-05-27 22:47:09.406639158 +0530
@@ -388,6 +388,7 @@
   /* figure out how many start points there are */
   for (i = 0; i < argc && strchr (""-!(),"", argv[i][0]) == NULL; i++)
     {
+      state.starting_path_length = strlen(argv[i]);  
       find(argv[i]);
     }
",1,1,Developer Fix,N/A,,
find.24e2271e,MzBiYjQ4ZG,find/ftsfind.c:279,find/util.c:300,find/pred.c:709,find/pred.c:809,,I saw the code flow and understood from output of program that length is not getting updated after updating first time. so started searching for code that sets path length. and then I found that condition was wrong to update path length.,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..2b915da 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -275,7 +275,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       mode = statbuf.st_mode;
     }

-  if (0 == ent->fts_level && (0u == state.starting_path_length))
+  if (0 == ent->fts_level || (0u == state.starting_path_length))
     state.starting_path_length = ent->fts_pathlen;

   if (0 != digest_mode(mode, ent->fts_path, ent->fts_name, &statbuf, 0))
",1,0,Regression,N/A,,
find.24e2271e,ZTBjYWY1Nj,find/pred.c:716,find/ftsfind.c:130,find/ftsfind.c:278,,,The length of starting part of current path processed is not re-calculated correctly.,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..4314d45 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -275,7 +275,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       mode = statbuf.st_mode;
     }
 
-  if (0 == ent->fts_level && (0u == state.starting_path_length))
+  if (0 == ent->fts_level)
     state.starting_path_length = ent->fts_pathlen;
               
   if (0 != digest_mode(mode, ent->fts_path, ent->fts_name, &statbuf, 0))
",1,1,Different but Correct,N/A,,
find.24e2271e,MTk0NjE0Mj,pred.c:712,ftsfind.c:279,pred.c:579,,,state.starting_path_length is not reset if once set at ftsfind.c:279. Thus leading to wrong pathname cut at pred.c:712,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..4314d45 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -275,7 +275,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       mode = statbuf.st_mode;
     }
 
-  if (0 == ent->fts_level && (0u == state.starting_path_length))
+  if (0 == ent->fts_level)
     state.starting_path_length = ent->fts_pathlen;
              
   if (0 != digest_mode(mode, ent->fts_path, ent->fts_name, &statbuf, 0))
",1,1,Different but Correct,N/A,,
find.24e2271e,ODY3ODM5YW,pred.c:712,ftsfind.c:278-279,pred.c:809,,,"If multiple directories are passed via command line, the statement in ftsfind.c:278 is incorrect. It will only be executed once because of the second term in the condition.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..4314d45 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -275,7 +275,7 @@ consider_visiting(FTS *p, FTSENT *ent)
       mode = statbuf.st_mode;
     }
 
-  if (0 == ent->fts_level && (0u == state.starting_path_length))
+  if (0 == ent->fts_level)
     state.starting_path_length = ent->fts_pathlen;
              
   if (0 != digest_mode(mode, ent->fts_path, ent->fts_name, &statbuf, 0))
",1,1,Different but Correct,N/A,,
find.66c536bb,ZTk0ZThkOD,find/parser.c:3094,find/parser.c:3013,find/parser.c:3128,,,"1. function ""get_comp_type"" modifying it's argument (shifts the pointer) called twice, second time called with same argument - it returns wrong output;
2. in line parser.c:3113 - comparsion performed with wrong (uninitialized) argument 
","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..e06b195 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -3096,20 +3096,21 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   struct predicate *our_pred;
   struct time_val tval;
   enum comparison_type comp;
-  const char *timearg;
+  const char *timearg, *timearg_orig;
   const char *errmsg = ""arithmetic overflow while converting %s days to a number of seconds"";
   time_t origin;

   if (!collect_arg(argv, arg_ptr, &timearg))
     return false;

+  timearg_orig = timearg;
   /* Decide the origin by previewing the comparison type. */
   origin = options.cur_day_start;

   if (get_comp_type(&timearg, &comp))
     {
       /* Remember, we invert the sense of the comparison, so this tests against COMP_LT instead of COMP_GT... */
-      if (COMP_LT == tval.kind)
+      if (COMP_LT == comp)
        {
          uintmax_t expected = origin + (DAYSECS-1);
          origin += (DAYSECS-1);
@@ -3124,7 +3125,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
        */
     }

-  if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
+  if (!get_relative_timestamp(timearg_orig, &tval, origin, DAYSECS, errmsg))
     return false;

   our_pred = insert_primary (entry);
",1,1,Different but Correct,N/A,,
find.66c536bb,YTA2MTE4ND,find/parser.c:268,find/parser.c:3112,find/parser.c:3122-3124,find/parser.c:3127,find/parser.c:3109,"there are actually two errors here.

1. tval.kind is used while not initialized yet (at find/parser.c:3112) and comp variable is never used. so this should be substituted with 'comp'

2. the value of timearg pointer was initialized at find/parser.c:3103, and was modified while used at find/parser.c:3109

but later, it should be used in original state at find/parser.c:3127, while it is actually used in modified state

the modification included shifting +/- character to the left of the pointer, so this part of the argument was lost for `get_relative_timestamp` function call","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..191c5f3 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -3097,6 +3097,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   struct time_val tval;
   enum comparison_type comp;
   const char *timearg;
+  const char *save_timearg;
   const char *errmsg = ""arithmetic overflow while converting %s days to a number of seconds"";
   time_t origin;
 
@@ -3106,10 +3107,11 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   /* Decide the origin by previewing the comparison type. */
   origin = options.cur_day_start;
 
+  save_timearg = timearg;
   if (get_comp_type(&timearg, &comp))
     {
       /* Remember, we invert the sense of the comparison, so this tests against COMP_LT instead of COMP_GT... */
-      if (COMP_LT == tval.kind)      
+      if (COMP_LT == comp)      
        {
          uintmax_t expected = origin + (DAYSECS-1);
          origin += (DAYSECS-1);
@@ -3123,6 +3125,8 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
        * will set tval.kind. 
        */
     }
+
+  timearg = save_timearg;
   
   if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
     return false;
",1,1,Developer-Fix,N/A,,
find.66c536bb,OTcyZjg1Mz,find/parser.c:3094-3157,find/parser.c:3167-3183,find/parser.c:3029-3078,find/parser.c:246-259,,The option -2 is considered as 2 and logic for this value is applied,"-  const char *timearg;
+  const char *timearg, *auxtimearg;
   const char *errmsg = ""arithmetic overflow while converting %s days to a number of seconds"";
   time_t origin;
 
@@ -3106,7 +3106,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   /* Decide the origin by previewing the comparison type. */
   origin = options.cur_day_start;
 
-  if (get_comp_type(&timearg, &comp))
+  if (get_comp_type(&auxtimearg, &comp))
     {
       /* Remember, we invert the sense of the comparison, so this tests against COMP_LT instead of COMP_GT... */
       if (COMP_LT == tval.kind)      ",1,1,Different but Correct,N/A,,
find.66c536bb,ZmZkMWM5OG,find/ftsfind.c:703,find/tree.c:1248,find/parser.c:3109,find/parser.c:3127,find/parser.c:3038,"For -mtime, function build_expression_tree() called from find/ftsfind.c:703 creates wrong tree. The error is in parse_time(), which is called from find/tree.c:1248. In get_comp_type(), called from find/parser.c:3109, the preceding sign ('-' or '+') is removed from the argument. Afterwards, function get_relative_timestamp(), see find/parser.c:3127 and find/parser.c:3038, is trying to check the preceding sign again, but it would always return EQ because the sign is not there, anymore.","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..dbe8503 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -3096,7 +3096,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   struct predicate *our_pred;
   struct time_val tval;
   enum comparison_type comp;
-  const char *timearg;
+  const char *timearg,*timearg1;
   const char *errmsg = ""arithmetic overflow while converting %s days to a number of seconds"";
   time_t origin;
 
@@ -3106,10 +3106,11 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   /* Decide the origin by previewing the comparison type. */
   origin = options.cur_day_start;
 
-  if (get_comp_type(&timearg, &comp))
+  timearg1 = timearg; /* MEOLIC BUG FIXING */
+  if (get_comp_type(&timearg1, &comp)) /* MEOLIC BUG FIXING */
     {
       /* Remember, we invert the sense of the comparison, so this tests against COMP_LT instead of COMP_GT... */
-      if (COMP_LT == tval.kind)      
+      if (COMP_LT == tval.kind) /* MEOLIC: HERE WE SHOULD HAVE ""comp"" INSTEAD OF ""tval.kind"" !! */      
         {
           uintmax_t expected = origin + (DAYSECS-1);
           origin += (DAYSECS-1);
",1,1,Different but Correct,N/A,,
find.66c536bb,MGJmMTU1N2,find/parser.c:3177,find/parser.c:3029,find/parser.c:3094,,,"get_comp_type had side effect of modifying the argument index. however, it was called twice and this lead to overwriting the comparison operator, therefore leading to a runtime behavior similar to COMP_EQ. as bug report stated","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..4f53c5a 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -3109,6 +3109,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   if (get_comp_type(&timearg, &comp))
     {
       /* Remember, we invert the sense of the comparison, so this tests against COMP_LT instead of COMP_GT... */
+
       if (COMP_LT == tval.kind)
        {
          uintmax_t expected = origin + (DAYSECS-1);
@@ -3122,6 +3123,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
       /* We discard the value of comp here, as get_relative_timestamp
        * will set tval.kind.
        */
+       if(comp != COMP_EQ) timearg--;
     }

   if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))

",1,1,Different but Correct,N/A,,
find.66c536bb,NDM5MjVmOT,find/parser.c:3165-3182,find/parser.c:3109,find/parser.c:3127,find/parser.c:3038,find/parser.c:3112,"Function get_comp_type() (find/parser.c:3165-3182) increments pointer to argument line when leading '+' or '-' occurs. In function parse_time() this function invoked twice, so second function invocation does not get '+' or '-' at the leading position even it was before. Also, due usage of uninitialized tval.kind variable (find/parser.c:3112) some time comparisons may be wrong. I believe that test script for this study may be incorrect due it reports good result when uninitialised variable bug remains unfixed.","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..2fbf657 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -3109,7 +3109,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   if (get_comp_type(&timearg, &comp))
     {
       /* Remember, we invert the sense of the comparison, so this tests against COMP_LT instead of COMP_GT... */
-      if (COMP_LT == tval.kind)      
+      if (COMP_LT == comp)      
         {
           uintmax_t expected = origin + (DAYSECS-1);
           origin += (DAYSECS-1);
@@ -3124,7 +3124,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
        */
     }
   
-  if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
+  if (!get_relative_timestamp(COMP_EQ == comp ? timearg : timearg - 1, &tval, origin, DAYSECS, errmsg))
     return false;
 
   our_pred = insert_primary (entry);",1,1,Different but Correct,N/A,,
find.66c536bb,NGU0NDRiM2,find/parser.c:3109-3109,find/parser.c:3112-3112,find/parser.c:3171-3171,find/parser.c:3127-3127,,"There are 2 errors:
1. Change one variable, but compare to another variable
2. Change pointer in one place, then using changed pointer in another place, although in second place we must using original value of pointer","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..33a6b2a 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -3097,6 +3097,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   struct time_val tval;
   enum comparison_type comp;
   const char *timearg;
+  const char *origin_timearg;
   const char *errmsg = ""arithmetic overflow while converting %s days to a number of seconds"";
   time_t origin;
 
@@ -3105,11 +3106,12 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
 
   /* Decide the origin by previewing the comparison type. */
   origin = options.cur_day_start;
+  origin_timearg = timearg;
 
   if (get_comp_type(&timearg, &comp))
     {
       /* Remember, we invert the sense of the comparison, so this tests against COMP_LT instead of COMP_GT... */
-      if (COMP_LT == tval.kind)      
+      if (COMP_LT == comp)
         {
           uintmax_t expected = origin + (DAYSECS-1);
           origin += (DAYSECS-1);
@@ -3124,6 +3126,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
        */
     }
   
+  timearg = origin_timearg;
   if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
     return false;
 
",1,1,Developer-Fix,N/A,,
find.66c536bb,NzBjMjQ0OT,find/parser.c:3099-3129,find/parser.c:3169-3186,find/parser.c:3028-3046,,,The timearg is not reverted to point to the '+' or '-' in the earlier case since get_comp_type() would have advanced it.Hence it was hitting the default case always and the comparison type was being taken as COMP_EQ.,"--- parser.c    2016-05-24 14:02:04.333155054 +0530
+++ parser_new.c    2016-05-24 14:02:49.145157191 +0530
@@ -3096,7 +3096,7 @@
   struct predicate *our_pred;
   struct time_val tval;
   enum comparison_type comp;
-  const char *timearg;
+  const char *timearg, *orig_timearg;
   const char *errmsg = ""arithmetic overflow while converting %s days to a number of seconds"";
   time_t origin;
",1,1,Developer-Fix,N/A,,
find.66c536bb,ZTBjYWY1Nj,find/tree.c:1248,find/parser.c:3110,find/parser.c:3125,,,"When parsing mtime (and other *time predicates) argument, the function to determine comparison type (minus or plus) is called twice; the problem is it modifies given string and cuts -/+ sign out.","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..5be5c2e 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -3096,13 +3096,18 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   struct predicate *our_pred;
   struct time_val tval;
   enum comparison_type comp;
-  const char *timearg;
+  const char *timearg, *old_timearg;
   const char *errmsg = ""arithmetic overflow while converting %s days to a number of seconds"";
   time_t origin;
 
   if (!collect_arg(argv, arg_ptr, &timearg))
     return false;
 
+
+  /* get_comp_type modifies our timearg, so save timearg
+   */
+  old_timearg = timearg;
+
   /* Decide the origin by previewing the comparison type. */
   origin = options.cur_day_start;
 
@@ -3119,12 +3124,9 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
                     _(""arithmetic overflow when trying to calculate the end of today""));
             }
         }
-      /* We discard the value of comp here, as get_relative_timestamp
-       * will set tval.kind. 
-       */
     }
   
-  if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
+  if (!get_relative_timestamp(old_timearg, &tval, origin, DAYSECS, errmsg))
     return false;
 
   our_pred = insert_primary (entry);
",1,1,Different but Correct,N/A,,
find.66c536bb,MTk0NjE0Mj,parser.c:3109,parser.c:3127,parser.c:3038,,,"Superfluous increment of timearg pointer that passed as pointer to pointer to get_comp_type() function at parser.c:3109 and again in get_relative_timestamp() function at parser.c:3127 (i.e. parser.c:3038)

Looks like the error caused by blind copy-pasteing of code blocks because there is another error with using uninitialized variable (parser.c:3109)
That uninitialized variable bugged me all the time I was fixing the error. I thought that it might not be involved.","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..c5abd77 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -3096,7 +3096,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   struct predicate *our_pred;
   struct time_val tval;
   enum comparison_type comp;
-  const char *timearg;
+  const char *timearg, *timearg_throwaway;
   const char *errmsg = ""arithmetic overflow while converting %s days to a number of seconds"";
   time_t origin;
 
@@ -3106,10 +3106,11 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   /* Decide the origin by previewing the comparison type. */
   origin = options.cur_day_start;
 
-  if (get_comp_type(&timearg, &comp))
+  timearg_throwaway = timearg;
+  if (get_comp_type(&timearg_throwaway, &comp))
     {
       /* Remember, we invert the sense of the comparison, so this tests against COMP_LT instead of COMP_GT... */
-      if (COMP_LT == tval.kind)      
+      if (COMP_LT == comp)      
        {
          uintmax_t expected = origin + (DAYSECS-1);
          origin += (DAYSECS-1);
",1,1,Different but Correct,N/A,,
find.66c536bb,MzBiYjQ4ZG,find/parser.c:3099,find/parser.c:3102,find/parser.c:3122,,,wrong incremented pointer was changing type of comparison as it was calling twice. Reset variable comment was written but actually reset was not done so reseted it.,"diff --git a/find/parser.c b/find/parser.c
index 75bbe69..b36d7bf 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -3096,20 +3096,20 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   struct predicate *our_pred;
   struct time_val tval;
   enum comparison_type comp;
-  const char *timearg;
+  const char *timearg,*realTimearg;
   const char *errmsg = ""arithmetic overflow while converting %s days to a number of seconds"";
   time_t origin;

   if (!collect_arg(argv, arg_ptr, &timearg))
     return false;
-
+  realTimearg = timearg; // save the time arg as get are doing ++ to pointer so keep one copy.
   /* Decide the origin by previewing the comparison type. */
   origin = options.cur_day_start;

   if (get_comp_type(&timearg, &comp))
     {
       /* Remember, we invert the sense of the comparison, so this tests against COMP_LT instead of COMP_GT... */
-      if (COMP_LT == tval.kind)      
+      if (COMP_LT == comp)
        {
          uintmax_t expected = origin + (DAYSECS-1);
          origin += (DAYSECS-1);
@@ -3122,6 +3122,7 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
       /* We discard the value of comp here, as get_relative_timestamp
        * will set tval.kind.
        */
+      timearg=realTimearg;
     }

   if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
",1,0,Incomplete Fix,Doesn't fix the problem for -mtime +2,,
find.66c536bb,ODY3ODM5YW,prec.c:278-288,pred.c:1246,parser.c:3172,parser.c:3102-3128,,At parser.c:3110 we call get_comp_type which increments timearg if the comp type is COMP_GT or COMP_LT. The call to get_relative_timestamp also calls get_comp_type. However at this point the timearg was already incremented and does not point to the sign anymore but to the number.,"diff --git a/find/parser.c b/find/parser.c
index 75bbe69..05e918e 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -3106,7 +3106,8 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
   /* Decide the origin by previewing the comparison type. */
   origin = options.cur_day_start;
 
-  if (get_comp_type(&timearg, &comp))
+  const char *timearg_tmp = timearg;
+  if (get_comp_type(&timearg_tmp, &comp))
     {
       /* Remember, we invert the sense of the comparison, so this tests against COMP_LT instead of COMP_GT... */
       if (COMP_LT == tval.kind)  ",1,1,Different but Correct,N/A,,
find.6e4cecb6,ZDc4NDZjMm,find/find.c:1094,find/find.c:132,find/find.c:137,,,The ternary operator at find.c:1094 messes up the logic and sets the O_NOFOLLOW flag for files that should be followed.,"diff --git a/find/find.c b/find/find.c
index d0c2d1f..bcf2ba3 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1091,7 +1091,7 @@ safely_chdir_nofollow(const char *dest,
                       struct stat *statbuf_dest,
                       enum ChdirSymlinkHandling symlink_handling)
 {
-  int extraflags = following_links() ? O_NOFOLLOW : 0;
+  int extraflags = following_links() ? 0 : O_NOFOLLOW;
 
   errno = 0;
   int fd = open(dest, O_RDONLY|extraflags);
",1,1,Developer Fix,N/A,,
find.6e4cecb6,YTA2MTE4ND,find/find.c:1139-1157,find/find.c:1088-1109,find/find.c:1618-1645,,,"Error was in wrong interpretation of following_links() option in safely_chdir_nofollow() function. When they should be followed, they weren't and vica versa.","diff --git a/find/find.c b/find/find.c
index d0c2d1f..456bf06 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1091,7 +1091,7 @@ safely_chdir_nofollow(const char *dest,
                      struct stat *statbuf_dest,
                      enum ChdirSymlinkHandling symlink_handling)
 {
-  int extraflags = following_links() ? O_NOFOLLOW : 0;
+  int extraflags = !following_links() ? O_NOFOLLOW : 0;
 
   errno = 0;
   int fd = open(dest, O_RDONLY|extraflags);
",1,1,Developer Fix,N/A,,
find.6e4cecb6,ZTk0ZThkOD,find/find.c:1618,find/find.c:1642,find/find.c:1094,,,extraflags variable wrongly calculated : result of logical operation was wrongly calculated,"diff --git a/find/find.c b/find/find.c
index d0c2d1f..bcf2ba3 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1091,7 +1091,7 @@ safely_chdir_nofollow(const char *dest,
                      struct stat *statbuf_dest,
                      enum ChdirSymlinkHandling symlink_handling)
 {
-  int extraflags = following_links() ? O_NOFOLLOW : 0;
+  int extraflags = following_links() ? 0 : O_NOFOLLOW;

   errno = 0;
   int fd = open(dest, O_RDONLY|extraflags);
",1,1,Developer Fix,N/A,,
find.6e4cecb6,ZmZkMWM5OG,find/find.c:1470,find/find.c:1083-1086,find/find.c:1094,,,"This is an almost syntactic mistake. Arguments to operator ? was switched. After a directory appear, find change to this directory for further processing, see find/find.c:1470. To prevent race conditions with symlinks (which are not connected to this error!),  special flag O_NOFOLLOW is used. Because of mistake it was used wrong, i.e. used in the case it shouldn't be used and not used in the case it should be used. Compare comment in find/find.c:1083-1086 and original implementation in find/find.c:1094.","diff --git a/find/find.c b/find/find.c
index d0c2d1f..7195ea0 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1091,7 +1091,7 @@ safely_chdir_nofollow(const char *dest,
                       struct stat *statbuf_dest,
                       enum ChdirSymlinkHandling symlink_handling)
 {
-  int extraflags = following_links() ? O_NOFOLLOW : 0;
+  int extraflags = following_links() ? 0 : O_NOFOLLOW; /* MEOLIC: BUG FIXING */
 
   errno = 0;
   int fd = open(dest, O_RDONLY|extraflags);",1,1,Developer Fix,N/A,,
find.6e4cecb6,NDM5MjVmOT,find/find.c:1097,find/find.c:1642,find/find.c:1618,find/find.c:132-144,,"Program tries to open dir file (find/find.c:1097) before change dir to that (find/find.c:1618). Program either passed O_NOFOLLOW flag to the open() system call or not depending on (-L,-H) options and current depth (find/find.c:132-144). But I noticed that flags is set to O_NOFOLLOW when following to links is need but it set to 0 when following symlinks is not required. So open() invoked with symlink and O_NOFOLLOW flag arguments causing error. ","diff --git a/find/find.c b/find/find.c                                                                                                                                                                                                       
index d0c2d1f..bcf2ba3 100644                                                                                                                                                                                                                
--- a/find/find.c                                                                                                                                                                                                                            
+++ b/find/find.c                                                                                                                                                                                                                            
@@ -1091,7 +1091,7 @@ safely_chdir_nofollow(const char *dest,                                                                                                                                                                                
                      struct stat *statbuf_dest,                                                                                                                                                                                             
                      enum ChdirSymlinkHandling symlink_handling)                                                                                                                                                                            
 {                                                                                                                                                                                                                                           
-  int extraflags = following_links() ? O_NOFOLLOW : 0;                                                                                                                                                                                      
+  int extraflags = following_links() ? 0 : O_NOFOLLOW;                                                                                                                                                                                      
                                                                                                                                                                                                                                             
   errno = 0;                                                                                                                                                                                                                                
   int fd = open(dest, O_RDONLY|extraflags);  ",1,1,Developer Fix,N/A,,
find.6e4cecb6,NGU0NDRiM2,find.c:1089-1136,find.c:1094-1094,find.c:1097-1097,,,Wrong conditional,"diff --git a/find/find.c b/find/find.c
index d0c2d1f..bcf2ba3 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1091,7 +1091,7 @@ safely_chdir_nofollow(const char *dest,
                       struct stat *statbuf_dest,
                       enum ChdirSymlinkHandling symlink_handling)
 {
-  int extraflags = following_links() ? O_NOFOLLOW : 0;
+  int extraflags = following_links() ? 0 : O_NOFOLLOW;
 
   errno = 0;
   int fd = open(dest, O_RDONLY|extraflags);
",1,1,Developer Fix,N/A,,
find.6e4cecb6,NzBjMjQ0OT,find/find.c:1213-1276,find/find.c:1140-1158,find/find.c:1094-1096,,,"Basically when the following_links() was returning true, the flag (extraflag ) O_NOFOLLOW was being set and hence the sym link was not being followed. 
Copying the comment from the source code below
""We use open() with O_NOFOLLOW, followed by fchdir().  This ensures
that we don't follow symbolic links (of course, we do follow them
if the -L option is in effect).""","--- find.c  2016-05-28 13:30:08.996362160 +0530
+++ find_new.c  2016-05-28 13:29:43.812360959 +0530
@@ -1092,7 +1092,7 @@
              struct stat *statbuf_dest,
              enum ChdirSymlinkHandling symlink_handling)
 {
-  int extraflags = following_links() ? O_NOFOLLOW : 0;
+  int extraflags = following_links() ? 0 : O_NOFOLLOW;

   errno = 0;
   int fd = open(dest, O_RDONLY|extraflags);
",1,1,Developer Fix,N/A,,
find.6e4cecb6,MTk0NjE0Mj,find.c:1618,find.c:1094,find.c:1102,,,safely_chdir_nofollow() returns SafeChdirFailSymlink at find.c:1618. Because of O_NOFOLLOW flag passed to open() it return ELOOP find.c:1102 . This flag is selected at find.c:1094 by mistake.,"diff --git a/find/find.c b/find/find.c
index d0c2d1f..bcf2ba3 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1091,7 +1091,7 @@ safely_chdir_nofollow(const char *dest,
                      struct stat *statbuf_dest,
                      enum ChdirSymlinkHandling symlink_handling)
 {
-  int extraflags = following_links() ? O_NOFOLLOW : 0;
+  int extraflags = following_links() ? 0 : O_NOFOLLOW;
 
   errno = 0;
   int fd = open(dest, O_RDONLY|extraflags);
",1,1,Developer Fix,N/A,,
find.6e4cecb6,ODY3ODM5YW,find.c:1637-1646,find.c:0,find.c:0,,,"I think there is only one interesting location find.c:1637-1646. The other 2 are garbage. Had to fill in something because required fields. Now I am wondering whether my understanding is correct.

If we fail to change into the directory, we print an error. Thats not correct if it is a symlink.","diff --git a/find/find.c b/find/find.c
index d0c2d1f..42b835a 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1633,10 +1633,12 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
              error (0, errno, ""."");
              state.exit_status = 1;
              break;
-             
+
+      case SafeChdirFailSymlink:
+        return;
+
            case SafeChdirFailNonexistent:
            case SafeChdirFailStat:
-           case SafeChdirFailSymlink:
            case SafeChdirFailNotDir:
            case SafeChdirFailChdirFailed:
              error (0, errno, ""%s"", pathname);
",1,0,Treating the Symptom,N/A,,
find.93623752,YTA2MTE4ND,find/tree.c:1265,find/tree.c:1267-1287,find/parser.c:914,,,"There seems to be a few errors here

At first, the condition check ordering in find/tree.c:1267-1287 is wrong.

Second, there was a null-pointer access at find/parser.c:914 when the insert_num funciton returned error","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..594f1fb 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -911,7 +911,10 @@ static boolean
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+  if(p)
+    {
+      p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+    }
   return p;
 }
 
diff --git a/find/tree.c b/find/tree.c
index e0c44c8..916ee92 100644
--- a/find/tree.c
+++ b/find/tree.c
@@ -1245,29 +1245,29 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
          i++;
        }
       oldi = i;
-      if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))
+      if (!argv[i] || !(*(parse_entry->parser_func)) (parse_entry, argv, &i))
        {
-         if (argv[i])
-           {
-             if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )
-               {
-                 /* The special parse function spat out the
-                  * predicate.  It must be invalid, or not tasty.
-                  */
-                 error (1, 0, _(""invalid predicate `%s'""),
-                        predicate_name);
-               }
+          if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )
+            {
+              /* The special parse function spat out the
+               * predicate.  It must be invalid, or not tasty.
+               */
+              error (1, 0, _(""invalid predicate `%s'""),
+                     predicate_name);
+            }
+          else
+            {
+             if (argv[oldi])
+               {
+                 error (1, 0, _(""invalid argument `%s' to `%s'""),
+                      argv[oldi], predicate_name);
+                }
              else
-               {
-                 error (1, 0, _(""invalid argument `%s' to `%s'""),
-                        argv[i], predicate_name);
-               }
-           }
-         else
-           {
-             /* Command line option requires an argument */
-             error (1, 0, _(""missing argument to `%s'""), predicate_name);
-           }
+               {
+                 /* Command line option requires an argument */
+                 error (1, 0, _(""missing argument to `%s'""), predicate_name);
+               }
+            }
        }
       else
        {
",1,1,Different but Correct,N/A,,
find.93623752,ZTk0ZThkOD,find/parser.c:914,find/tree.c:1263,find/tree.c:1250,,,"segfault: find/parser.c:914 - return value is not checked - dereferencing null pointer;
starting from find/tree.c:1250: referring to wrong arvg index when printing erorrs
","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..3fffd23 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -911,7 +911,8 @@ static boolean
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+  if (p)
+         p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
   return p;
 }

diff --git a/find/tree.c b/find/tree.c
index e0c44c8..101488c 100644
--- a/find/tree.c
+++ b/find/tree.c
@@ -1247,7 +1247,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
       oldi = i;
       if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))
        {
-         if (argv[i])
+         if (argv[oldi] && argv[oldi][0] != '-')
            {
              if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )
                {
@@ -1260,7 +1260,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
              else
                {
                  error (1, 0, _(""invalid argument `%s' to `%s'""),
-                        argv[i], predicate_name);
+                        argv[oldi], predicate_name);
                }
            }
          else
",1,1,Different but Correct,N/A,,
find.93623752,OTcyZjg1Mz,find/find.c:131-217,find/tree.c:1192-1285,find/parser.c:237-238,find/parser.c:3094-3156,,Parser module is not working properly for these options,"--- a/find/tree.c
+++ b/find/tree.c
@@ -1247,6 +1247,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
       oldi = i;
       if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))
        {
+          i = oldi;
          if (argv[i])
            {
              if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )",1,1,Different but Correct,N/A,,
find.93623752,ZmZkMWM5OG,find/parser.c:914,find/tree.c:1248,find/tree.c:1250,find/tree.c:1263,,"There are two different errors. For -ctime and for invalid arguments in general, the reporting of the error is wrong. 
Function to recognize the given parameter is called from find/tree.c:1248. It will increment variable i even for the wrong argument. Thus for explaining the error, oldi should be used, see find/tree.c:1250 and find/tree.c:1263.

For -gid there is an additional error. If argument is missing, then we get segmentation fault in find/parser.c:914, because function inser_num return empty p. We must add checking in find/parser.c:914.","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..1513c1c 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -911,7 +911,7 @@ static boolean
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+  if (p) p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2; /* MEOLIC: BUG FIXING */
   return p;
 }
 
diff --git a/find/tree.c b/find/tree.c
index e0c44c8..ab51060 100644
--- a/find/tree.c
+++ b/find/tree.c
@@ -1247,7 +1247,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
       oldi = i;
       if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))
         {
-          if (argv[i])
+          if (argv[oldi]) /* MEOLIC: BUG FIXING */
             {
               if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )
                 {
@@ -1260,7 +1260,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
               else
                 {
                   error (1, 0, _(""invalid argument `%s' to `%s'""),
-                         argv[i], predicate_name);
+                         argv[oldi], predicate_name); /* MEOLIC: BUG FIXING */
                 }
             }
           else
",1,1,Different but Correct,N/A,,
find.93623752,MGJmMTU1N2,find/parser.c:910,find/parser.c:3124,find/parser.c:3255,,,multiple causes. a null pointer deference followed by incrementing an argv pointer even if argument not parsed yet,"diff --git a/find/parser.c b/find/parser.c
index 75bbe69..a80fc78 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -910,8 +910,9 @@ parse_fstype (const struct parser_table* entry, char **argv, int *arg_ptr)
 static boolean
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
+
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+  if(p)   p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
   return p;
 }

@@ -3124,8 +3125,10 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
        */
     }

-  if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
+  if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg)){
+    (*arg_ptr)--;
     return false;
+  }

   our_pred = insert_primary (entry);
   our_pred->args.reftime = tval;
@@ -3255,6 +3258,7 @@ insert_num (char **argv, int *arg_ptr, const struct parser_table *entry)
          }
        return our_pred;
       }
+      else  (*arg_ptr)--;
   }
   return NULL;
 }
",1,1,Developer Fix,N/A,,
find.93623752,ZTRmYWE5Nj,find/tree.c:1249-1271,find/parser.c:3126-3127,find/parser.c:3096-3124,,,The argv parameter is NULL pointer.,"diff --git a/find/tree.c b/find/tree.c
index e0c44c8..8d0bd5c 100644
--- a/find/tree.c
+++ b/find/tree.c
@@ -1245,6 +1245,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
          i++;
        }
       oldi = i;
+      i--;
       if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))
        {
          if (argv[i])
",1,0,Regression,"Now, even correct arguments are reported as incorrect ones.",,
find.93623752,NDM5MjVmOT,find/parser.c:913-914,find/parser.c:1113-1115,find/parser.c:1159-1165,find/parser.c:2210-2212,find/tree.c:1248-1271,"It is actually not a real error. It is rather incomplete code missing checking values returned from function. Function insert_num() returns NULL on bad arguments. Next, NULL pointer dereferenced without any checks in many places. Return value for get_relative_timestamp() on error does not handled properly too (find/parser.c:3127). Error conditions does not handled fully at (find/tree.c:1248-1271).","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..365f03c 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -911,8 +911,11 @@ static boolean
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
-  return p;
+  if (p)
+    p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+  else
+    --*arg_ptr;
+  return !!p;
 }
 
 static boolean
@@ -1112,8 +1115,11 @@ parse_inum (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p =  insert_num (argv, arg_ptr, entry);
   /* inode number is exact match only, so very low proportions of files match */
-  p->est_success_rate = 1e-6;
-  return p;
+  if (p)
+    p->est_success_rate = 1e-6;
+  else
+    --*arg_ptr;
+  return !!p;
 }
 
 /* -ipath is deprecated (at RMS's request) in favour of 
@@ -1157,13 +1163,18 @@ static boolean
 parse_links (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  if (p->args.numinfo.l_val == 1)
-    p->est_success_rate = 0.99;
-  else if (p->args.numinfo.l_val == 2)
-    p->est_success_rate = 0.01;
+  if (p)
+    {
+      if (p->args.numinfo.l_val == 1)
+        p->est_success_rate = 0.99;
+      else if (p->args.numinfo.l_val == 2)
+        p->est_success_rate = 0.01;
+      else
+        p->est_success_rate = 1e-3;
+    }
   else
-    p->est_success_rate = 1e-3;
-  return p;
+    --*arg_ptr;
+  return !!p;
 }
 
 static boolean
@@ -2208,8 +2219,11 @@ static boolean
 parse_uid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
-  return p;
+  if (p)
+    p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+  else
+    --*arg_ptr;
+  return !!p;
 }
 
 static boolean
@@ -3125,7 +3139,10 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
     }
   
   if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
-    return false;
+    {
+      --*arg_ptr;
+      return false;
+    }
 
   our_pred = insert_primary (entry);
   our_pred->args.reftime = tval;
diff --git a/find/tree.c b/find/tree.c
index e0c44c8..9d08188 100644
--- a/find/tree.c
+++ b/find/tree.c
@@ -1257,6 +1257,10 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
                   error (1, 0, _(""invalid predicate `%s'""),
                          predicate_name);
                 }
+              else if ((i == oldi) && (NULL != find_parser (argv[i])))
+                {
+                    error (1, 0, _(""missing argument to `%s'""), predicate_name);
+                }
               else
                 {
                   error (1, 0, _(""invalid argument `%s' to `%s'""),",1,1,Developer Fix,N/A,,
find.93623752,NGU0NDRiM2,parser.c:911-913,parser.c:3094-3155,parser.c:3127-3128,,,"There are 2 errors:
1. Bug in parse_gid() function when we do not check up return value for not NULL
2. In parse_gid() and in parse_time() we do not decrease arg_ptr if parameter is wrong","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..7759866 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -911,8 +911,17 @@ static boolean
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
-  return p;
+
+  if(p)
+  {
+     p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+     return true;
+  }
+  else
+  {
+      --*arg_ptr;
+      return false;
+  }
 }
 
 static boolean
@@ -3125,7 +3134,10 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
     }
   
   if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
-    return false;
+  {
+      --*arg_ptr;
+      return false;
+  }
 
   our_pred = insert_primary (entry);
   our_pred->args.reftime = tval;
",1,1,Developer Fix,N/A,,
find.93623752,NzBjMjQ0OT,find/tree.c:1242-1270,find/parser.c:3112-3114,find/parser.c:561-573,find/parser.c:910-924,,The arg_ptr was getting incremented in the parser function(when the parser function calls collect_arg() ) and hence argv[i] was evaluating to null if there were only 3 arguments. The if condition to check the error cases needed some modifications.,"--- tree.c  2016-05-25 18:06:31.006021442 +0530
+++ tree_new.c  2016-05-25 18:07:10.902023345 +0530
@@ -1247,7 +1247,7 @@
       oldi = i;
       if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))
    {
-     if (argv[i])
+     if (argv[oldi])
        {
          if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )
        {
@@ -1260,7 +1260,7 @@
          else
        {
          error (1, 0, _(""invalid argument `%s' to `%s'""),
-            argv[i], predicate_name);
+            argv[oldi], predicate_name);
        }
        }
      else
--- parser.c    2016-05-25 18:08:06.426025994 +0530
+++ parser_new.c    2016-05-25 18:07:25.326024033 +0530
@@ -911,8 +911,16 @@
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
+  if(p)
+  {
   p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
-  return p;
+  return true;
+  }
+
+  else
+  {
+  return false;
+  }
 }
                                                                                                                                   
 static boolean
",1,1,Different but Correct,N/A,,
find.93623752,ZTBjYWY1Nj,find/tree.c:1248,find/parser.c:914,find/parser.c:3130,,,"First, when parsing gid, return structure isn't checked for null pointer. Second, for some cases when parsing gid and ctime argument index in agrv is incremented incorrectly.","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..e071611 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -911,7 +911,10 @@ static boolean
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+  if (p)
+    p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+  else
+    (*arg_ptr)--;
   return p;
 }
 
@@ -3125,7 +3128,10 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
     }
   
   if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
+  {
+    (*arg_ptr)--;
     return false;
+  }
 
   our_pred = insert_primary (entry);
   our_pred->args.reftime = tval;
",1,1,Developer Fix,N/A,,
find.93623752,MzBiYjQ4ZG,find/tree.c:1250,find/tree.c:1269,find/parser.c:914,,,in first problem wrong argument were taken to check. And in second wrong way to return pointer as a boolean.,"diff --git a/find/parser.c b/find/parser.c
index 75bbe69..f6bb24d 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -911,8 +911,15 @@ static boolean
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
-  return p;
+  if(p)
+  {
+    p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+    return true;
+  }
+  else
+  {
+   return false;
+  }
 }

 static boolean
diff --git a/find/tree.c b/find/tree.c
index e0c44c8..d6c1038 100644
--- a/find/tree.c
+++ b/find/tree.c
@@ -1247,7 +1247,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
       oldi = i;
       if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))
        {
-         if (argv[i])
+         if (argv[oldi] && argv[oldi][0] != '-')
            {
              if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )
                {
@@ -1260,7 +1260,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
              else
                {
                  error (1, 0, _(""invalid argument `%s' to `%s'""),
-                        argv[i], predicate_name);
+                        argv[oldi], predicate_name);
                }
            }
          else
",1,1,Different but Correct,N/A,,
find.93623752,MTk0NjE0Mj,parser.c:3102,parser.c:911,tree.c:1248,,,"tree.c:1248 rely on return value of parse_* functions and on a number of eaten arguments by the parser.
First, segfault (parser.c:911) was a weird case, because the parse_* functions clearly states that they returns boolean, but instead of boolean some of that functions return pointer. (At this point one should spend a lot more time investigating if it is intended behavior) And all of them use that pointer without checking it's validity.
There was some other functions that does the same (like parse_inum)

In the last case predicate treats another one as an argument, and complains about wrong argument (after fixing the segfault). Because parse_ functions advance the arg_ptr (`i` in tree.c).","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..3a39828 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -911,8 +911,10 @@ static boolean
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
+  if (p == NULL)
+    return false;
   p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
-  return p;
+  return true;
 }
 
 static boolean
@@ -1111,9 +1113,11 @@ static boolean
 parse_inum (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p =  insert_num (argv, arg_ptr, entry);
+  if (p == NULL)
+    return false;
   /* inode number is exact match only, so very low proportions of files match */
   p->est_success_rate = 1e-6;
-  return p;
+  return true;
 }
 
 /* -ipath is deprecated (at RMS's request) in favour of 
@@ -1157,13 +1161,15 @@ static boolean
 parse_links (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
+  if (p == NULL)
+    return false;
   if (p->args.numinfo.l_val == 1)
     p->est_success_rate = 0.99;
   else if (p->args.numinfo.l_val == 2)
     p->est_success_rate = 0.01;
   else
     p->est_success_rate = 1e-3;
-  return p;
+  return true;
 }
 
 static boolean
@@ -2208,8 +2214,10 @@ static boolean
 parse_uid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
+  if (p == NULL)
+    return false;
   p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
-  return p;
+  return true;
 }
 
 static boolean
@@ -3125,7 +3133,10 @@ parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
     }
   
   if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
-    return false;
+    {
+      *arg_ptr -= 1;
+      return false;
+    }
 
   our_pred = insert_primary (entry);
   our_pred->args.reftime = tval;
@@ -3255,6 +3266,8 @@ insert_num (char **argv, int *arg_ptr, const struct parser_table *entry)
           }
         return our_pred;
       }
+    else
+      *arg_ptr -= 1;
   }
   return NULL;
 }
diff --git a/find/tree.c b/find/tree.c
index e0c44c8..f657a80 100644
--- a/find/tree.c
+++ b/find/tree.c
@@ -1247,7 +1247,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
       oldi = i;
       if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))
         {
-          if (argv[i])
+          if (argv[i] && argv[i][0] != '-')
             {
               if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )
                 {
",1,1,Developer Fix,N/A,,
find.93623752,ODY3ODM5YW,parser.c:913-916,tree.c:1243-1270,parser.c:3232-3260,,,"in commit 7102a229 someone changed the code quite a lot but was sloppy :)

The index into argv is wrong if i != oldi. Parsing might change the i. So we should use oldi","diff --git a/find/parser.c b/find/parser.c
index 75bbe69..1ae9abb 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -911,7 +911,8 @@ static boolean
 parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
 {
   struct predicate *p = insert_num (argv, arg_ptr, entry);
-  p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
+  if (p)
+    p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
   return p;
 }
 
diff --git a/find/tree.c b/find/tree.c
index e0c44c8..e0269a7 100644
--- a/find/tree.c
+++ b/find/tree.c
@@ -1247,7 +1247,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
       oldi = i;
       if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))
        {
-         if (argv[i])
+         if (argv[oldi])
            {
              if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )
                {
@@ -1260,7 +1260,7 @@ build_expression_tree(int argc, char *argv[], int end_of_leading_options)
              else
                {
                  error (1, 0, _(""invalid argument `%s' to `%s'""),
-                        argv[i], predicate_name);
+                        argv[oldi], predicate_name);
                }
            }
          else
",1,1,Different but Correct,N/A,,
find.b445af98,ZTk0ZThkOD,find/tree.c:1190,find/ftsfind.c:226,find/util.c:978,,,"not really sure what is *root* cause, but applying  fix 
""eval_tree->need_stat = !state.have_stat;"" in find/fstfing.c:237 fixes the output and it behaves as expected","diff --git a/find/ftsfind.c b/find/ftsfind.c
index b3d44f8..c958163 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -234,6 +234,7 @@ visit(FTS *p, FTSENT *ent, struct stat *pstat)

   /* Apply the predicates to this path. */
   eval_tree = get_eval_tree();
+  eval_tree->need_stat = !state.have_stat;
   apply_predicate(ent->fts_path, pstat, eval_tree);

   /* Deal with any side effects of applying the predicates. */
",1,0,Incorrect workaround,stat() is not supposed to be called,,
find.b445af98,YTA2MTE4ND,find/util.c:524,find/ftsfind.c:230,find/util.c:518-542,find/ftsfind.c:495,,"-H option should make `find` to dive into symlinks on the first-level directory items only (that is, on the arguments provided to find). state.curdepth is checked for that reason at find/util.c:524, but state.curdepth is updated _after_ checking type of the object at find/ftsfind.c:230, and symlink is dived into on 2nd level too at find/ftsfind.c:495.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index b3d44f8..5f67eb0 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -227,7 +227,6 @@ visit(FTS *p, FTSENT *ent, struct stat *pstat)
 {
   struct predicate *eval_tree;
   
-  state.curdepth = ent->fts_level;
   state.have_stat = (ent->fts_info != FTS_NS) && (ent->fts_info != FTS_NSOK);
   state.rel_pathname = ent->fts_accpath;
   state.cwd_dir_fd   = p->fts_cwd_fd;
@@ -490,6 +489,8 @@ consider_visiting(FTS *p, FTSENT *ent)
        }
     }
 
+  state.curdepth = ent->fts_level;
+
   if (mode)
     {
       if (!digest_mode(mode, ent->fts_path, ent->fts_name, &statbuf, 0))
",1,1,Developer Fix,N/A,,
find.b445af98,OTcyZjg1Mz,find/ftsfind.c:389-547,find/ftsfind.c:228-243,find/pred.c:1708-1779,,,When calculating stat information about symlinks it is overwritten at sections 1 and 2 and when we reach section 3 this info is no longer available,"  if (state.have_stat)
      mode = stat_buf->st_mode;
   else
-     mode = state.type;
+     if (get_statinfo(pathname,  state.rel_pathname, stat_buf) != 0)
+       return false;
+
+     //mode = state.type;
+     mode = stat_buf->st_mode;
 
 #ifndef S_IFMT
   /* POSIX system; check `mode' the slow way. */",1,0,Incorrect workaround,stat() is not supposed to be called,,
find.b445af98,ZmZkMWM5OG,find/ftsfind.c:617-620,find/ftsfind.c:230,find/ftsfind.c:495,find/util.c:599-612,find/pred.c:1749,"Global variable state.curdepth is not updated before call to consider_visiting(), see find/ftsfind.c:617-620. It is updated in visit(), see find/ftsfind.c:230, but it is to late there. Function digest_mode() called before visit(), see find/ftsfind.c:495, is needed the updated information. Because state.curdepth is wrong, the condition in find/util.c:629 is true (see find/util.c:599-612) and therefore variable mode will get the wrong value. Afterwards, when comparing mode and type in find/pred.c:1749 the result will be false and the file, which should be printed will not be printed.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index b3d44f8..aa90e9b 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -227,7 +227,7 @@ visit(FTS *p, FTSENT *ent, struct stat *pstat)
 {
   struct predicate *eval_tree;
   
-  state.curdepth = ent->fts_level;
+  /* state.curdepth = ent->fts_level; */ /* MEOLIC: NOT NEEDED HERE */
   state.have_stat = (ent->fts_info != FTS_NS) && (ent->fts_info != FTS_NSOK);
   state.rel_pathname = ent->fts_accpath;
   state.cwd_dir_fd   = p->fts_cwd_fd;
@@ -617,6 +617,7 @@ find(char *arg)
           state.have_stat = false;
           state.have_type = !!ent->fts_statp->st_mode;
           state.type = state.have_type ? ent->fts_statp->st_mode : 0;
+      state.curdepth = ent->fts_level; /* MEOLIC: FIXED BUG */
           consider_visiting(p, ent);
         }
       fts_close(p);
",1,1,Developer Fix,N/A,,
find.b445af98,NDM5MjVmOT,find/ftsfind.c:493-497,find/util.c:629-636,find/util.c:607,,,"Program invokes digest_mode() to fill 'state' structure fields (find/ftsfind.c:493-497).  Depending on tree position and command line options, it may call get_statinfo() function, which dereferences symlinks. With -H command line option supplied, program always decides to dereference symlinks to a files contained in directory passed as command line argument but not deeper when checks file types.","diff --git a/find/util.c b/find/util.c
index 27db863..eea102d 100644
--- a/find/util.c
+++ b/find/util.c
@@ -604,7 +604,7 @@ following_links(void)
     case SYMLINK_ALWAYS_DEREF:
       return 1;
     case SYMLINK_DEREF_ARGSONLY:
-      return (state.curdepth == 0);
+      return (state.curdepth == -1);
     case SYMLINK_NEVER_DEREF:
     default:
       return 0;",1,0,Treating Symptom,N/A,,
find.b445af98,MTk0NjE0Mj,util.c:607,util.c:629,ftsfind.c:496,ftsfind.c:230,,"state.curdepth used before needed assignment.
digest_mode() at util.c:629 follows symlink because state.curdepth at util.c:607 sill 0 like we are parsing commandline arguments. Because of that mode changes to actual mode of the dir, not the symlink and pred_type() (i.e. -type l) check fail.
In case without -H state.curdepth is not used. In case without -type l the pred_type() is not used.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index b3d44f8..2dc3c4c 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -227,7 +227,6 @@ visit(FTS *p, FTSENT *ent, struct stat *pstat)
 {
   struct predicate *eval_tree;
   
-  state.curdepth = ent->fts_level;
   state.have_stat = (ent->fts_info != FTS_NS) && (ent->fts_info != FTS_NSOK);
   state.rel_pathname = ent->fts_accpath;
   state.cwd_dir_fd   = p->fts_cwd_fd;
@@ -399,6 +398,8 @@ consider_visiting(FTS *p, FTSENT *ent)
            quotearg_n_style(0, options.err_quoting_style, ent->fts_path),
            quotearg_n_style(1, options.err_quoting_style, ent->fts_accpath));
   
+  state.curdepth = ent->fts_level;
+
   if (ent->fts_info == FTS_DP)
     {
       left_dir();
",1,1,Developer Fix,N/A,,
find.c8491c11 ,YTA2MTE4ND,find/parser.c:1274-1277,find/parser.c:1215,find/parser.c:1362,,,array bounds were not checked,"diff --git a/find/parser.c b/find/parser.c
index a707546..0684291 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1313,6 +1313,11 @@ parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
           * past the test name (for most other tests, this is already done)
           */
          (*arg_ptr)++;
+
+          if ((argv == NULL) || (argv[*arg_ptr] == NULL))
+            {
+              return false;
+            }
          
          our_pred = insert_primary (entry);
",1,1,Developer Fix,N/A,,
find.c8491c11 ,ZTk0ZThkOD,find/parser.c:1357,find/parser.c:1350,find/parser.c:1351,,,"function 'fatal_file_error' called at parser.c:1357 with null pointer as filename, that causes segfault in library function 'quotearg_buffer_restyled'; Root cause of errors is in between parser.c:1350 and parser.c:1357 - code doesn't check if -neverXX followed by argument","diff --git a/find/parser.c b/find/parser.c
index a707546..d634973 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1350,6 +1350,8 @@ parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
          else
            {
              struct stat stat_newer;
+             if (!argv[*arg_ptr])
+               return false;

              /* Stat the named file. */
              set_stat_placeholders(&stat_newer);",1,0,Incomplete Fix,Null pointer might still propagate via parser.c:1342 or 1347,,
find.c8491c11 ,OTcyZjg1Mz,find/ftsfind.c:690-693,find/tree.c:1240-1245,find/parser.c:1269-1376,,,Index out of bounds used when accessing array of args at find/parser.c function parse_newerXY(). The variable arg_ptr reachs the value 2 that is out of bounds (we only have argv[0] and argv[1]),"--- a/find/parser.c
+++ b/find/parser.c
@@ -1313,6 +1313,12 @@ parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
           * past the test name (for most other tests, this is already done)
           */
          (*arg_ptr)++;
+
+          /* when no more args - return error  */
+          if((argv[*arg_ptr]) == NULL)
+          {
+            return false;
+          }
          
          our_pred = insert_primary (entry);",1,1,Developer Fix,N/A,,
find.c8491c11 ,ZmZkMWM5OG,find/parser.c:1352,find/util.c:896,find/util.c:887,,,"For -neweraa, function parse_newerXY expect a file as the next argument. The root cause for the error is a missing check if the next argument exists and thus function optionp_stat (which is used if -P) at find/parser.c:1352 fail. Probably, it was expected that a call to fatal_file_error() in the next line will properly report the error, but this is not hapening. Function fatal_file_error()  will delegate a work to a function quotearg_n_style() which is outside of this project, see find/util.c:896 and find/util.c:887, and which does not correctly work for an empty argument.","diff --git a/find/parser.c b/find/parser.c
index a707546..2867afc 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1351,6 +1351,14 @@ parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
             {
               struct stat stat_newer;
               
+          /* MEOLIC: BUG FIXING */
+          if (!argv[*arg_ptr]) {
+                  error(1, 0,
+                        _(""The %s test needs an argument""),
+                        quotearg_n_style(0, options.err_quoting_style, argv[*arg_ptr-1]));
+                  }
+          /* MEOLIC: END OF FIX */
+
               /* Stat the named file. */
               set_stat_placeholders(&stat_newer);
               if ((*options.xstat) (argv[*arg_ptr], &stat_newer))
",1,0,Incomplete Fix,Null pointer might still propagate via parser.c:1342 or 1347,,
find.c8491c11 ,MGJmMTU1N2,find/util.c:893,find/util.c:895,find/util.c:897,,,invalid formatting of a printf-like message. less arguments than expected,"diff --git a/find/util.c b/find/util.c
index 4792080..e42e27e 100644
--- a/find/util.c
+++ b/find/util.c
@@ -893,7 +893,9 @@ safely_quote_err_filename (int n, char const *arg)
 void
 fatal_file_error(const char *name)
 {
+  if(name)
   error (1, errno, ""%s"", safely_quote_err_filename(0, name));
+  else   error (1, errno, ""%s"","""");
   /*NOTREACHED*/
   abort();
 }




",1,0,Incomplete Fix,Null pointer might still propagate via parser.c:1342 or 1347,,
find.c8491c11 ,ZTRmYWE5Nj,find/parse.c:1356-1357,quotearg.c:249,find/parse.c:1315,,,null pointer,"diff --git a/find/parser.c b/find/parser.c
index a707546..077c065 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1312,7 +1312,7 @@ parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
          /* Because this item is ARG_SPECIAL_PARSE, we have to advance arg_ptr
           * past the test name (for most other tests, this is already done)
           */
-         (*arg_ptr)++;
+        /* (*arg_ptr)++; */

          our_pred = insert_primary (entry);
",1,0,Regression,Fix impacts other inputs where some arguments might not be parsed at all.,,
find.c8491c11 ,NDM5MjVmOT,find/parser.c:1315,find/parser.c:1356,find/parser.c:1357,,,"Arguments array index is increased at (find/parser.c:1315). If -newerXY is last command line argument, increased value is NULL. There are no NULL check for that case. It tried to use at find/parser.c:1356 as stat() argument and after stat() failed it tried to print out error message but failed due NULL argument.","diff --git a/find/parser.c b/find/parser.c
index a707546..adcff65 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1313,6 +1313,14 @@ parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
            * past the test name (for most other tests, this is already done)
            */
           (*arg_ptr)++;
+          if (!argv[*arg_ptr])
+            {
+              error(1, 0,
+                _(""The `%s' test needs an argument""),
+                argv[*arg_ptr-1]);
+              return 0;
+            }
+              
           
           our_pred = insert_primary (entry);
 ",1,1,Developer Fix,N/A,,
find.c8491c11 ,NGU0NDRiM2,quoteargs.c:249-249,parser.c:1269-1269,parser.c:1315-1315,,,Do not check for number of arguments,"diff --git a/find/parser.c b/find/parser.c
index a707546..c10d56b 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1314,6 +1314,11 @@ parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
            */
           (*arg_ptr)++;
           
+          if(!argv[*arg_ptr])
+          {
+                  return 0;
+          }
+
           our_pred = insert_primary (entry);
 
 
",1,1,Developer Fix,N/A,,
find.c8491c11 ,NzBjMjQ0OT,find/parser.c:1311-1317,lib/quotearg.c:248-250,find/parser.c:1267-1270,,,The code was trying to deferencing a null pointer and hence the segmentation fault. This happens when -newerXY is not supplied with an argument.,"--- parser.c    2016-05-27 00:39:46.954702674 +0530
+++ parser_new.c    2016-05-27 00:46:06.426720776 +0530
@@ -1312,7 +1312,14 @@
      /* Because this item is ARG_SPECIAL_PARSE, we have to advance arg_ptr
       * past the test name (for most other tests, this is already done)
       */
-     (*arg_ptr)++;
+
+      if(argv[*arg_ptr + 1] != NULL)
+          (*arg_ptr)++;
+      else
+      {
+      error(1, 0, _(""The %s test needs an argument""),
+                          quotearg_n_style(0, options.err_quoting_style, argv[*arg_ptr]));
+      }

      our_pred = insert_primary (entry);
",1,1,Developer Fix,N/A,,
find.c8491c11 ,MzBiYjQ4ZG,find/utils.c:898,find/parser.c:1313,find/parser.c:1319,,,case not handled. Null value check was missing.,"diff --git a/find/parser.c b/find/parser.c
index a707546..9b8f38e 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1313,7 +1313,9 @@ parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
           * past the test name (for most other tests, this is already done)
           */
          (*arg_ptr)++;
-         
+
+         if(argv[*arg_ptr] == NULL)
+               error (1,0, ""The `%s' test needs an argument"",argv[--(*arg_ptr)]); 
          our_pred = insert_primary (entry);",1,1,Developer Fix,N/A,,
find.c8491c11 ,ZTBjYWY1Nj,gnulib/lib/quotearg.c:249,find/parser.c:1358,find/ftsfind.c:693,,,"When parsing command line parameters to the program at first region, it comes down to escaping filename being passed as argument to -newer option (at second region). The function that does actual parameter escaping (third region) does not check the absence of parameter and so dereferences null pointer.","diff --git a/find/parser.c b/find/parser.c
index a707546..0714974 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1354,7 +1354,12 @@ parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
               /* Stat the named file. */
               set_stat_placeholders(&stat_newer);
               if ((*options.xstat) (argv[*arg_ptr], &stat_newer))
-                fatal_file_error(argv[*arg_ptr]);
+              {
+                if (argv[*arg_ptr])
+                  fatal_file_error(argv[*arg_ptr]);
+                else
+                  error(1, 0, _(""Option -newer requires argument""));
+              }
               
               if (!get_stat_Ytime(&stat_newer, y, &our_pred->args.reftime.ts))
                 {",1,0,Incomplete Fix,Null pointer might still propagate via parser.c:1342 or 1347,,
find.c8491c11 ,MTk0NjE0Mj,parser.c:1360,parser.c:1360,parser.c:1360,,,Segfault deep inside fatal_file_error() just because the passed pointer to the filename was 0 at parser.c:1360. parse_newerXY() does not check for existence of it's argument.,"diff --git a/find/parser.c b/find/parser.c
index a707546..799c42d 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -1309,6 +1309,9 @@ parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
        {
          struct predicate *our_pred;
          
+         if (argv[(*arg_ptr)+1] == NULL)
+           error(1, 0, _(""The `%s' test needs an argument""), argv[*arg_ptr]);
+
          /* Because this item is ARG_SPECIAL_PARSE, we have to advance arg_ptr
           * past the test name (for most other tests, this is already done)
           */
",1,1,Developer Fix,N/A,,
find.c8491c11 ,ODY3ODM5YW,quotearg.c:249,quotearg.c:667,util.c:896,,,There is an OOB access in quotearg.c:249 on arg. arg is NULL,"diff --git a/find/util.c b/find/util.c
index 4792080..b1e0ccc 100644
--- a/find/util.c
+++ b/find/util.c
@@ -893,7 +893,7 @@ safely_quote_err_filename (int n, char const *arg)
 void
 fatal_file_error(const char *name)
 {
-  error (1, errno, ""%s"", safely_quote_err_filename(0, name));
+  error (1, errno, ""%s"", (name ? safely_quote_err_filename(0, name) : """"));
   /*NOTREACHED*/
   abort();
 }
",1,0,Incomplete Fix,Null pointer might still propagate via parser.c:1342 or 1347,,
find.dbcb10e9,YTA2MTE4ND,find/parser.c:2739,find/parser.c:2759,find/parser.c:2762,,,Subjective error with pointer-to-pointer leveling,"diff --git a/find/parser.c b/find/parser.c
index 23a3374..33d7f43 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2736,7 +2736,7 @@ get_num (char *str,
         double *fractional_part,
         enum comparison_type *comp_type)
 {
-  char **pend;
+  char *pend;
   boolean ok;
   
   if (str == NULL)
@@ -2756,16 +2756,16 @@ get_num (char *str,
       break;
     }
 
-  ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
+  ok = xstrtoumax (str, &pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if (pend)
        {
-         if ('.'== (**pend))
+         if ('.'== (*pend))
            {
              /* We have a fractional part. */
              const char *p;
-             ok = xstrtod(*pend, &p, fractional_part, strtod);
+             ok = xstrtod(pend, &p, fractional_part, strtod);
              if (!ok)
                {
                  *fractional_part = 0.0;
",1,1,Different but Correct Fix,N/A,,
find.dbcb10e9,ZTk0ZThkOD,find/parser.c:2762,find/parser.c:2762,find/parser.c:2762,,,de-referencing NULL pointer at find/parser.c:2762,"diff --git a/find/parser.c b/find/parser.c
index 23a3374..667c7eb 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2736,7 +2736,7 @@ get_num (char *str,
         double *fractional_part,
         enum comparison_type *comp_type)
 {
-  char **pend;
+  char **pend = NULL;
   boolean ok;

   if (str == NULL)
@@ -2759,7 +2759,7 @@ get_num (char *str,
   ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if (pend && *pend)
        {
          if ('.'== (**pend))
            {
",1,1,Developer-Fix,N/A,,
find.dbcb10e9,OTcyZjg1Mz,find/find.c:157-159,find/tree.c:1270-1448,find/tree.c:2669-2670,find/parser.c:2634-1,find/parser.c:2762-2763,Accessing pointer to pointer not initialized,"diff --git a/find/parser.c b/find/parser.c
index 23a3374..037988a 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2759,7 +2759,7 @@ get_num (char *str,
   ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if ((pend) && (*pend))
        {
          if ('.'== (**pend))
            {",1,1,Developer-Fix,N/A,,
find.dbcb10e9,ZmZkMWM5OG,find/parser.c:2739,find/parser.c:2759,find/parser.c:2759,,,"Function get_num which is called in the case of -mtime make a call to function xstrtoumax, see find/parser.c:2759. Function xstrtoumax requires that there is an allocated memory to store one resulting pointer (second parameter). The way used to define variable ""pend"" which is passed as a second parameter is not correct because it does not allocate memory. ","diff --git a/find/parser.c b/find/parser.c
index 23a3374..73ba292 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2736,7 +2736,7 @@ get_num (char *str,
 	 double *fractional_part,
 	 enum comparison_type *comp_type)
 {
-  char **pend;
+  char *pend; /* MEOLIC: FIXED BUG */
   boolean ok;
   
   if (str == NULL)
@@ -2756,16 +2756,16 @@ get_num (char *str,
       break;
     }
 
-  ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
+  ok = xstrtoumax (str, &pend, 10, num, """") == LONGINT_OK; /* MEOLIC: FIXED BUG */
   if (ok && fractional_part)
     {
       if (*pend)
 	{
-	  if ('.'== (**pend))
+	  if ('.'== (*pend)) /* MEOLIC: FIXED BUG */
 	    {
 	      /* We have a fractional part. */
 	      const char *p;
-	      ok = xstrtod(*pend, &p, fractional_part, strtod);
+	      ok = xstrtod(pend, &p, fractional_part, strtod); /* MEOLIC: FIXED BUG */
 	      if (!ok)
 		{
 		  *fractional_part = 0.0;
",1,1,Different but Correct Fix,,,
find.dbcb10e9,MGJmMTU1N2,find/parser.c:2731,find/parser.c:2768,find/parser.c:2739,,,deferring an unallocated pointer,"diff --git a/find/parser.c b/find/parser.c
index 23a3374..6fd62d6 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2736,7 +2736,7 @@ get_num (char *str,
         double *fractional_part,
         enum comparison_type *comp_type)
 {
-  char **pend;
+  char *end,**pend=&end;
   boolean ok;

   if (str == NULL)

",1,1,Treating Symptom,N/A,,
find.dbcb10e9,NDM5MjVmOT,find/parser.c:2739,find/parser.c:2759,find/parser.c:2762,gnulib/lib/xstrtol.c:86,,"Variable char **pend used incorrectly in this case. Pointer to a pointer used uninitialized here (find/parser.c:2739) , so it don't provide actual storage memory for pointer changed by xstrtoumax() function (../gnulib/lib/xstrtol.c:86). Access to random area of memory pointed by uninitialized char**pend caused segfault. (find/parser.c:2759, find/parser.c:2762)","diff --git a/find/parser.c b/find/parser.c                                                                                                 
index 23a3374..41b4af3 100644                                                                                                                                                                                                                
--- a/find/parser.c                                                                                                                                                                                                                          
+++ b/find/parser.c                                                                                                                                                                                                                          
@@ -2736,7 +2736,7 @@ get_num (char *str,                                                                                                                                                                                                    
         double *fractional_part,                                                                                                                                                                                                            
         enum comparison_type *comp_type)                                                                                                                                                                                                    
 {                                                                                                                                                                                                                                           
-  char **pend;                                                                                                                                                                                                                              
+  char *pend = NULL;                                                                                                                                                                                                                        
   boolean ok;                                                                                                                                                                                                                               
                                                                                                                                                                                                                                             
   if (str == NULL)                                                                                                                                                                                                                          
@@ -2756,16 +2756,16 @@ get_num (char *str,                                                                                                                                                                                                  
       break;                                                                                                                                                                                                                                
     }                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                             
-  ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;                                                                                                                                                                                   
+  ok = xstrtoumax (str, &pend, 10, num, """") == LONGINT_OK;                                                                                                                                                                                  
   if (ok && fractional_part)                                                                                                                                                                                                                
     {                                                                                                                                                                                                                                       
-      if (*pend)                                                                                                                                                                                                                            
+      if (pend)                                                                                                                                                                                                                             
        {                                                                                                                                                                                                                                    
-         if ('.'== (**pend))                                                                                                                                                                                                                
+         if ('.'== (*pend))                                                                                                                                                                                                                 
            {                                                                                                                                                                                                                                
              /* We have a fractional part. */                                                                                                                                                                                               
              const char *p;                                                                                                                                                                                                                 
-             ok = xstrtod(*pend, &p, fractional_part, strtod);                                                                                                                                                                              
+             ok = xstrtod(pend, &p, fractional_part, strtod);                                                                                                                                                                               
              if (!ok)                                                                                                                                                                                                                       
                {                                                                                                                                                                                                                            
                  *fractional_part = 0.0;              ",1,1,Different but Correct Fix,,,
find.dbcb10e9,ZTRmYWE5Nj,find/parser.c:2742-2760,gnulib/xstrtol.c:78,find/parser.c:2669-2670,,,pointer NULL,"diff --git a/find/parser.c b/find/parser.c
index 23a3374..234ccaa 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2756,6 +2756,7 @@ get_num (char *str,
       break;
     }

+  pend = str;
   ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
",0,0,Incomplete Fix,Test case fails (no crash but no expected output either),,
find.dbcb10e9,NGU0NDRiM2,find/parser.c:2739-2739,find/parser.c:2759-2759,parser.c:2764-2764,,,"Send to function pointer to c string (local variable), and assume that this pointer will be changed, but it did not. Developer must send pointer to local variable.","diff --git a/find/parser.c b/find/parser.c
index 23a3374..33d7f43 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2736,7 +2736,7 @@ get_num (char *str,
          double *fractional_part,
          enum comparison_type *comp_type)
 {
-  char **pend;
+  char *pend;
   boolean ok;
   
   if (str == NULL)
@@ -2756,16 +2756,16 @@ get_num (char *str,
       break;
     }
 
-  ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
+  ok = xstrtoumax (str, &pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if (pend)
         {
-          if ('.'== (**pend))
+          if ('.'== (*pend))
             {
               /* We have a fractional part. */
               const char *p;
-              ok = xstrtod(*pend, &p, fractional_part, strtod);
+              ok = xstrtod(pend, &p, fractional_part, strtod);
               if (!ok)
                 {
                   *fractional_part = 0.0;
",1,1,Different but Correct Fix,,,
find.dbcb10e9,NTU0ZTZlNT,find/parser.c:2739,find/parser.c:2759,find/parser.c:2762-2779,,,"pend could still be null after xstrtoumax call.  pend should just have been a string instead of an array of strings.  therefore, checking on 'pend' instead of '*pend' in line 2762 could trap situations when pend would be null.","diff --git a/find/parser.c b/find/parser.c
index 23a3374..ad73c2e 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2736,7 +2736,7 @@ get_num (char *str,
         double *fractional_part,
         enum comparison_type *comp_type)
 {
-  char **pend;
+  char *pend;
   boolean ok;
   
   if (str == NULL)
@@ -2756,16 +2756,16 @@ get_num (char *str,
       break;
     }
 
-  ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
+  ok = xstrtoumax (str, &pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if (pend)
        {
-         if ('.'== (**pend))
+         if ('.'== (*pend))
            {
              /* We have a fractional part. */
              const char *p;
-             ok = xstrtod(*pend, &p, fractional_part, strtod);
+             ok = xstrtod(pend, &p, fractional_part, strtod);
              if (!ok)
                {
                  *fractional_part = 0.0;",1,1,Different but Correct Fix,,,
find.dbcb10e9,NzBjMjQ0OT,find/parser.c:2668-2670,find/parser.c:2633-2635,find/parser.c:2761-2763,,,The program was trying to dereference a null pointer unneccessarily,"--- parser.c    2016-05-29 14:26:39.732774583 +0530
+++ parser_new.c    2016-05-29 14:27:30.220776991 +0530
@@ -2757,31 +2757,6 @@
     }

   ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
-  if (ok && fractional_part)
-    {
-      if (*pend)
-   {
-     if ('.'== (**pend))
-       {
-         const char *p;
-         ok = xstrtod(*pend, &p, fractional_part, strtod);
-         if (!ok)
-       {
-         *fractional_part = 0.0;
-         ok = true;
-       }
-       }
-     else
-       {
-         *fractional_part = 0.0;
-       }
-   }
-      else
-   {
-     *fractional_part = 0.0;
-   }
-    }
-    
   return ok;
 }",1,0,Treating Symptom,N/A,,
find.dbcb10e9,MzYzM2Y4MG,find/parse.c:2764,find/parse.c:2764,find/parse.c:2764,,,"The value pend is null. And when the program get the value of *pend, it will have a segmentation fault.","diff --git a/find/parser.c b/find/parser.c
index 23a3374..ea1af45 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2759,7 +2759,7 @@ get_num (char *str,
   ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if (pend)
        {
          if ('.'== (**pend))
            {
",1,1,Developer-Fix,N/A,,
find.dbcb10e9,OTRmYzA5OD,find/parser.c:2739,find/parser.c:2758,find/parser.c:2763,find/parser.c:2767,,Memory for pointer pend is not allocated,"diff --git a/find/parser.c b/find/parser.c
index 23a3374..d20a9b7 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2736,9 +2736,8 @@ get_num (char *str,
         double *fractional_part,
         enum comparison_type *comp_type)
 {
-  char **pend;
+  char *pend;
   boolean ok;
-  
   if (str == NULL)
     return false;
   switch (str[0])
@@ -2756,16 +2755,16 @@ get_num (char *str,
       break;
     }
 
-  ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
+  ok = xstrtoumax (str, &pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if (pend)
        {
-         if ('.'== (**pend))
+         if ('.'== (*pend))
            {
              /* We have a fractional part. */
              const char *p;
-             ok = xstrtod(*pend, &p, fractional_part, strtod);
+             ok = xstrtod(pend, &p, fractional_part, strtod);
              if (!ok)
                {
                  *fractional_part = 0.0;",1,1,Different but Correct Fix,N/A,,
find.dbcb10e9,MzBiYjQ4ZG,find/parser.c:2762-2762,find/parser.c:2764-2764,find/parser.c:2764-2764,,,If condition was not properly used and comparison of pointer and character was not used properly.,"diff --git a/find/parser.c b/find/parser.c
index 23a3374..a9e67fb 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2759,9 +2759,9 @@ get_num (char *str,
   ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if (*pend != NULL)
        {
-         if ('.'== (**pend))
+         if ('.'== pend)
            {
              /* We have a fractional part. */
              const char *p;
",1,0,Treating Symptom,Nullpointer is still dereference. Only now it happens to not crash,,
find.dbcb10e9,ZTBjYWY1Nj,gnulib/lib/xstrtol.c:79,find/parser.c:2778,find/parser.c:2674,,,"The cause of error was bad checking of the return parameters of function __xstrtol, which parses the argument string of -mtime option to actual numbers. The check for pointer to pointer to char correctness was wrong.","diff --git a/find/parser.c b/find/parser.c
index 23a3374..2a4148a 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2759,7 +2759,7 @@ get_num (char *str,
   ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if (pend && *pend)
         {
           if ('.'== (**pend))
             {",1,1,Developer-Fix,N/A,,
find.dbcb10e9,MTk0NjE0Mj,parser.c:2762,parser.c:2739,parser.c:2739,,,`pend` variable at parser.c:2739 declared and used parser.c:2762 completely wrong.,"diff --git a/find/parser.c b/find/parser.c
index 23a3374..33d7f43 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2736,7 +2736,7 @@ get_num (char *str,
         double *fractional_part,
         enum comparison_type *comp_type)
 {
-  char **pend;
+  char *pend;
   boolean ok;
   
   if (str == NULL)
@@ -2756,16 +2756,16 @@ get_num (char *str,
       break;
     }
 
-  ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
+  ok = xstrtoumax (str, &pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if (pend)
        {
-         if ('.'== (**pend))
+         if ('.'== (*pend))
            {
              /* We have a fractional part. */
              const char *p;
-             ok = xstrtod(*pend, &p, fractional_part, strtod);
+             ok = xstrtod(pend, &p, fractional_part, strtod);
              if (!ok)
                {
                  *fractional_part = 0.0;
",1,1,Different but Correct Fix,N/A,,
find.dbcb10e9,ODY3ODM5YW,parser.c:2758-2761,parser.c:0,parser.c:0,,,Missing NULL pinter check,"diff --git a/find/parser.c b/find/parser.c
index 23a3374..2a4148a 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2759,7 +2759,7 @@ get_num (char *str,
   ok = xstrtoumax (str, pend, 10, num, """") == LONGINT_OK;
   if (ok && fractional_part)
     {
-      if (*pend)
+      if (pend && *pend)
        {
          if ('.'== (**pend))
            {
",1,1,Developer-Fix,N/A,,
find.e1d0a991 ,ZDc4NDZjMm,find/ftsfind.c:346-359,find/pred.c:494,find/pred.c:312,,,"The error is caused because the path passed to the function executing the execdir predicate is wrong.

This happens because the flags passed to fts_open were  wrong.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..fdaf71e 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -346,7 +346,7 @@ find(char *arg)
   switch (options.symlink_handling)
     {
     case SYMLINK_ALWAYS_DEREF:
-      ftsoptions |= FTS_COMFOLLOW|FTS_LOGICAL;
+      ftsoptions |= FTS_COMFOLLOW;
       break;
           
     case SYMLINK_DEREF_ARGSONLY:
",1,0,Incorrect workaround,FTS_LOGICAL is supposed to be set,,
find.e1d0a991 ,YTA2MTE4ND,find/pred.c:484-490,find/pred.c:467-471,find/pred.c:1561-1577,,,"This bug involves two sub-issues

1. The working directory is never changed for execdir. (This is not needed when -P option is on as fts library chdirs itself to the correct directory. But when -L or -H is on, fts doesn't use this feature on some reason)

2. execdir command parameters ('{}') are substituted as a full path from starting point instead of just a file name (same comment as above)
at find/pred.c:484-490 and find/pred.c:467-471","diff --git a/find/parser.c b/find/parser.c
index 889d437..cd20df7 100644
--- a/find/parser.c
+++ b/find/parser.c
@@ -2146,6 +2146,7 @@ new_insert_exec_ok (const char *action,
   our_pred = insert_primary_withpred (entry, func);
   our_pred->side_effects = our_pred->no_default_print = true;
   execp = &our_pred->args.exec_vec;
+  execp->state.wd = 0;
 
   if ((func != pred_okdir) && (func != pred_ok))
     {
diff --git a/find/pred.c b/find/pred.c
index ec8e94a..a27665a 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -457,6 +457,28 @@ new_impl_pred_exec (const char *pathname, struct stat *stat_buf,
   size_t len = strlen(pathname);
 
   (void) stat_buf;
+
+  if (execp->use_current_dir)
+    {
+      /* Workaround for the bug #find3:
+       * 1. cut the pathname at its basename
+       * 2. tell launch function to cwd into deepest directory possible 
+       *
+       * Here we do the 1st part
+       */
+      char *cut_slash = strrchr(pathname, '/');
+
+      if (cut_slash)
+        {
+          if (execp->state.wd == 0)
+            {
+              *cut_slash = 0;
+              execp->state.wd = open(pathname, O_RDONLY | O_DIRECTORY);
+              *cut_slash = '/';
+            }
+          pathname = cut_slash + 1; // cut at character next after last slash
+        }
+    }
   
   if (execp->multiple)
     {
@@ -1573,12 +1595,25 @@ launch (const struct buildcmd_control *ctl,
              _exit (1);
            }
        }
+      else if (buildstate->wd)
+        {
+          if(fchdir(buildstate->wd))
+            {
+              error (0, errno, ""%s"", buildstate->cmd_argv[0]);
+              _exit (1);
+            }
+        }
       
       execvp (buildstate->cmd_argv[0], buildstate->cmd_argv);
       error (0, errno, ""%s"", buildstate->cmd_argv[0]);
       _exit (1);
     }
 
+  if (buildstate->wd)
+    {
+      close(buildstate->wd);
+      buildstate->wd = 0;
+    }
 
   /* In parent; set up for next time. */
   bc_clear_args(ctl, buildstate);
diff --git a/lib/buildcmd.h b/lib/buildcmd.h
index 15f0418..614cc67 100644
--- a/lib/buildcmd.h
+++ b/lib/buildcmd.h
@@ -47,6 +47,9 @@ struct buildcmd_state
 
   /* to-do flag. */
   int todo;
+
+  /* working directory if non-zero */
+  int wd;
 };
",0,0,Regression,N/A,,
find.e1d0a991 ,ZmZkMWM5OG,find/ftsfind.c:349,find/ftsfind.c:364,find/ftsfind.c:373,,,"If using -L then FTS_LOGICAL flag is set in find/ftsfind.c:349 and passed to fts_open in find/ftsfind.c:364. Because of this flag, no chdir is performed during fts_read, called from find/ftsfind.c:373. I have tried without FTS_LOGICAL flag but then the results are even more wrong (link are not followed). Thus, if I suppose, that the error is not in fts_read (because that function is from fts.c which is outside of current project) then (1) something must be added to tell fts_read that chdir must be made or (2) chdir must be invoked and also struct ent adapted just before find/ftsfind.c:375. Please note, that chdir must be invoked, otherwise one could not obtain the correct result e.g. for ""-execdir pwd"".",no solution,N/A,N/A,N/A,N/A,,
find.e1d0a991 ,ZTRmYWE5Nj,find/ftsfind.c:346-359,find/ftsfind.c:373-376,find/ftsfind.c:125-130,,,"346   switch (options.symlink_handling)
347     {
348     case SYMLINK_ALWAYS_DEREF:
349       ftsoptions |= FTS_COMFOLLOW|FTS_LOGICAL;
350       break;
351
352     case SYMLINK_DEREF_ARGSONLY:
353       ftsoptions |= FTS_COMFOLLOW;
354       break;
355
356     case SYMLINK_NEVER_DEREF:
357       ftsoptions |= FTS_PHYSICAL;
358       break;
359     }
Different symlink handling option have different fts opening option.","diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..fdaf71e 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -346,7 +346,7 @@ find(char *arg)
   switch (options.symlink_handling)
     {
     case SYMLINK_ALWAYS_DEREF:
-      ftsoptions |= FTS_COMFOLLOW|FTS_LOGICAL;
+      ftsoptions |= FTS_COMFOLLOW;
       break;

     case SYMLINK_DEREF_ARGSONLY:
",1,0,Incorrect workaround,FTS_LOGICAL is supposed to be set,,
find.e1d0a991 ,MGJmMTU1N2,find/gnulib/lib/fts.c:779,find/gnulib/lib/fts.c:1309,find/gnulib/lib/fts.c:720,,,"when looking for files, the symlink file is considered ""cannot-stat-the-file"" leading to later ignore it in search results","find/gnulib/lib/fts.c:779
+ CLR(FTS_NOCHDIR);
",,None,Incorrect workaround,FTS_NOCHDIR is supposed to be set. Test Fails,,
find.e1d0a991 ,NDM5MjVmOT,find/ftsfind.c:348-350,lib/fts.c:236-238,lib/fts.c:313-315,lib/fts.c:525,,"When -L command line option specified, program logic set FTS_LOGICAL option flag (find/ftsfind.c:348-350). Directory to change is opened in function fts_open(lib/fts.c:313-315) and actually changed in fts_read() (lib/fts.c:525) only if FTS_NOCHDIR flag is not set. But this flag is always set for FTS_LOGICAL mode. So this behaviour is not a real bug but predefined program actions.","diff --git a/find/pred.c b/find/pred.c
index ec8e94a..5aacb60 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -28,6 +28,7 @@
 #include <sys/stat.h>
 #include <assert.h>
 #include <fcntl.h>
+#include <libgen.h>
 #include ""xalloc.h""
 #include ""dirname.h""
 #include ""human.h""
@@ -506,10 +507,37 @@ pred_exec (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 boolean
 pred_execdir (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
-   const char *prefix = (state.rel_pathname[0] == '/') ? NULL : ""./"";
    (void) &pathname;
-   return new_impl_pred_exec (state.rel_pathname, stat_buf, pred_ptr,
+   if (SYMLINK_ALWAYS_DEREF == options.symlink_handling)
+     {
+       /* handle change dir due it do not happens before */
+       /* using POSIX versions of parse pathname functions, so they may alter argument */
+       char copy_base [PATH_MAX], copy_dir [PATH_MAX], cur_dir [PATH_MAX], *dir_name, *base_name, *p;
+       boolean ret_val;
+
+       strncpy (copy_base, state.rel_pathname, PATH_MAX);
+       strncpy (copy_dir, state.rel_pathname, PATH_MAX);
+       dir_name = dirname (copy_dir);
+       base_name = basename (copy_base);
+       p = getcwd (cur_dir, PATH_MAX);
+       if (!p)
+          error (1, errno, _(""cannot get current directory""));
+       if (chdir (dir_name))
+          error (1, errno, _(""cannot change directory into %s""), dir_name);
+       
+       ret_val = new_impl_pred_exec (base_name, stat_buf, pred_ptr, ""./"", 2);
+
+       if (p && chdir (cur_dir))
+          error (1, errno, _(""cannot change directory back into %s""), dir_name);
+       return ret_val;
+     }
+   else
+     {
+       /* keep old style behaviour */
+       const char *prefix = (state.rel_pathname[0] == '/') ? NULL : ""./"";
+       return new_impl_pred_exec (state.rel_pathname, stat_buf, pred_ptr,
 			      prefix, (prefix ? 2 : 0));
+     }
 }
 
 boolean",1,1,Developer Fix,N/A,,
find.e1d0a991 ,MTk0NjE0Mj,gnulib/lib/fts.c:237,pred.c:1531,pred.c:507,,,"I was not able to understand the cause of the bug. I've spent a lot of time just to get to the gnulib/lib/fts.c:237. According to it this bug is ""desired"" behavior (desired by programmers).

After this I went back to the launch() and *pred_exec() functions. Maybe it's possible to analyze the state of the program (is -L in effect) and change working dir and args somewhere before pushing them to the list (i.e.  bc_do_insert/bc_push_arg). But I can't do in *properly* in 45 minutes.
", ,N/A,N/A,N/A,N/A,,
find.e1d0a991 ,MzBiYjQ4ZG,find/ftsfind.c:348,find/ftsfind.c:507-541,find/util.c:501,find/util.c:485,find/parser.c:315,if -L is given then everything will be considered as a link and it will be followed and it will print full path.,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 4b597ec..2af8855 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -74,6 +74,17 @@
 #ifdef STAT_MOUNTPOINTS
 static void init_mounted_dev_list(void);
 #endif
+
+/* check if it is rdirectory or not
+ */
+int isDirectory(const char *path)
+{
+   struct stat statbuf;
+   if (stat(path, &statbuf) != 0)
+       return 0;
+   return S_ISDIR(statbuf.st_mode);
+}
+
 ^L
 /* We have encountered an error which shoudl affect the exit status.
  * This is normally used to change the exit status from 0 to 1.
@@ -503,6 +514,8 @@ main (int argc, char **argv)
       else if (0 == strcmp(""-L"", argv[i]))
        {
          /* Meaning: dereference all symbolic links. */
+          // check if next argument is directory then no need to follow always deref stat
+          if(!isDirectory)
          set_follow_state(SYMLINK_ALWAYS_DEREF);
        }
       else if (0 == strcmp(""-P"", argv[i]))",1,0,Incomplete Fix,N/A,,
find.e1d0a991 ,ODY3ODM5YW,pred.c:511,ftsfind.c:128,ftsfind.c:0,,,Did not have enough time to fully understand bug. The ent->fts_accpath is different at ftsfind.c:128 from the 2 executions. I am not familiar with fts_read and I am not sure whether this is a bug in find or in the library,mmmmmmm There is no path. I ran out of time. So all answers related to bug fixing are bogus.,N/A,N/A,N/A,N/A,,
find.e6680237,YTA2MTE4ND,find/pred.c:626-633,find/pred.c:532,find/pred.c:543-549,find/pred.c:511-529,,"the working directory for -execdir option at variable execp->wd_for_exec was successfully initialized at first, but never updated after that","diff --git a/find/pred.c b/find/pred.c
index e2e8dfb..345ede4 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -510,21 +510,25 @@ pred_empty (const char *pathname, struct stat *stat_buf, struct predicate *pred_
 static bool
 record_exec_dir (struct exec_val *execp)
 {
-  if (!execp->wd_for_exec)
+  if (execp->wd_for_exec)
     {
-      /* working directory not already known, so must be a *dir variant,
-        and this must be the first arg we added.   However, this may
-        be -execdir foo {} \; (i.e. not multiple).  */
-      assert (!execp->state.todo);
-
-      /* Record the WD. */
-      execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));
-      execp->wd_for_exec->name = NULL;
-      execp->wd_for_exec->desc = openat (state.cwd_dir_fd, ""."", O_RDONLY);
-      if (execp->wd_for_exec->desc < 0)
-       return false;
-      set_cloexec_flag (execp->wd_for_exec->desc, true);
+      free(execp->wd_for_exec);
+      execp->wd_for_exec = NULL;
     }
+
+  /* working directory not already known, so must be a *dir variant,
+   and this must be the first arg we added.   However, this may
+   be -execdir foo {} \; (i.e. not multiple).  */
+  assert (!execp->state.todo);
+  
+  /* Record the WD. */
+  execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));
+  execp->wd_for_exec->name = NULL;
+  execp->wd_for_exec->desc = openat (state.cwd_dir_fd, ""."", O_RDONLY);
+  if (execp->wd_for_exec->desc < 0)
+    return false;
+  set_cloexec_flag (execp->wd_for_exec->desc, true);
+
   return true;
 }
",1,0,Regression,"Fix impacts inputs where execp->todo is not false s.t. the assertion fails. If execp->todo could never be false, the developer fix would substitute a superflous condition.",,
find.e6680237,OTcyZjg1Mz,find/ftsfind.c:332-539,find/pred.c:533-616,find/pred.c:511-528,,,We do not update correctly the current working directory PWD," static bool
 record_exec_dir (struct exec_val *execp)
 {
-  if (!execp->wd_for_exec)
+  if (!execp->state.todo) //(!execp->wd_for_exec)
     {
       /* working directory not already known, so must be a *dir variant,
         and this must be the first arg we added.   However, this may
         be -execdir foo {} \; (i.e. not multiple).  */
-      assert (!execp->state.todo);
+      //assert (!execp->state.todo);
 
       /* Record the WD. */
       execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));",1,1,Developer Fix,N/A,,
find.e6680237,ZmZkMWM5OG,find/ftsfind.c:198,find/pred.c:523,find/pred.c:513,,,"For -execdir the command must be executed in working directory. There is an element wd_for_exec, which is used to denote working directory. When apply_predicate, see find/ftsfind.c:198, is called for element in different directory as in the previous call, this should be set to 0 to request call of ""openat"", see find/pred.c:523 which will update working directory. Decision about the need for the update is done in find/pred.c:513.
","diff --git a/find/pred.c b/find/pred.c
index e2e8dfb..33a9511 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -542,6 +542,12 @@ new_impl_pred_exec (const char *pathname,
 
   if (is_exec_in_local_dir (pred_ptr->pred_func))
     {
+
+      /* MEOLIC: BUG FIXING, BUT THIS IS NOT THE EFFICIENT ONE */
+      /* THIS COULD BE DONE ONLY IF DIR IS CHANGED SINCE LAST CALL */
+      execp->wd_for_exec = 0;
+      /* MEOLIC: END OF FIX */
+
       /* For -execdir/-okdir predicates, the parser did not fill in
          the wd_for_exec member of sturct exec_val.  So for those
          predicates, we do so now.
",1,0,Regression,"Fix impacts inputs where execp->todo is not false s.t. the assertion fails. If execp->todo could never be false, the developer fix would substitute a superflous condition.",,
find.e6680237,MGJmMTU1N2,find/pred.c:500,find/pred.c:600,find/pred.c:2035,,,a pointer for exec working directory was not cleared after use. that lead to the pointer not being updated with the new path.,"diff --git a/find/ftsfind.c b/find/ftsfind.c
index 49aef9b..42d83af 100644
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -525,6 +525,7 @@ consider_visiting (FTS *p, FTSENT *ent)
    * that it doesn't tell us just before we leave a directory.  For the moment,
    * we punt and don't allow the arguments to build up.
    */
+
   if (state.execdirs_outstanding)
     {
       show_outstanding_execdirs (stderr);
diff --git a/find/pred.c b/find/pred.c
index e2e8dfb..f643836 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -520,6 +520,8 @@ record_exec_dir (struct exec_val *execp)
       /* Record the WD. */
       execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));
       execp->wd_for_exec->name = NULL;
+      //[rc]
+      //printf("" state.cwd_dir= %s\n"",execp->wd_for_exec->desc);
       execp->wd_for_exec->desc = openat (state.cwd_dir_fd, ""."", O_RDONLY);
       if (execp->wd_for_exec->desc < 0)
        return false;
@@ -602,6 +604,11 @@ new_impl_pred_exec (const char *pathname,

       /* Actually invoke the command. */
       bc_do_exec (&execp->ctl, &execp->state);
+      //[rc]
+      if (is_exec_in_local_dir (pred_ptr->pred_func))
+      {
+         execp->wd_for_exec =NULL;
+      }
       if (WIFEXITED(execp->last_child_status))
        {
          if (0 == WEXITSTATUS(execp->last_child_status))
diff --git a/find/util.c b/find/util.c
index b072fea..ba355c0 100644
--- a/find/util.c
+++ b/find/util.c
@@ -390,7 +390,6 @@ do_complete_pending_execdirs (struct predicate *p)
            }
        }
     }
-
   do_complete_pending_execdirs (p->pred_right);
 }
",1,0,Regression,"Fix impacts inputs where execp->todo is not false s.t. the assertion fails. If execp->todo could never be false, the developer fix would substitute a superflous condition.",,
find.e6680237,NDM5MjVmOT,find/pred.c:513-527,find/pred.c:549-550,find/pred.c:604-605,,,First occurrence allocating resource which incorrectly used in the rest occurrences but it does not applicable for rest cases. The resource must be invalidated and freed after use.,"diff --git a/find/pred.c b/find/pred.c                                                                                                                                                                                                       
index e2e8dfb..311b3b4 100644                                                                                                                                                                                                                
--- a/find/pred.c                                                                                                                                                                                                                            
+++ b/find/pred.c                                                                                                                                                                                                                            
@@ -602,6 +602,12 @@ new_impl_pred_exec (const char *pathname,                                                                                                                                                                               
                                                                                                                                                                                                                                             
       /* Actually invoke the command. */                                                                                                                                                                                                    
       bc_do_exec (&execp->ctl, &execp->state);                                                                                                                                                                                              
+      if (execp->wd_for_exec && execp->wd_for_exec != initial_wd)                                                                                                                                                                           
+        {                                                                                                                                                                                                                                   
+          free_cwd (execp->wd_for_exec);                                                                                                                                                                                                    
+          free (execp->wd_for_exec);                                                                                                                                                                                                        
+          execp->wd_for_exec = NULL;                                                                                                                                                                                                        
+        }                                                                                                                                                                                                                                   
       if (WIFEXITED(execp->last_child_status))                                                                                                                                                                                              
        {                                                                                                                                                                                                                                    
          if (0 == WEXITSTATUS(execp->last_child_status))  ",1,0,Regression,"Fix impacts inputs where execp->todo is not false s.t. the assertion fails. If execp->todo could never be false, the developer fix would substitute a superflous condition.",,
find.e6680237,ZTRmYWE5Nj,find/ftsfind.c:190-204,find/util.c:1090-1108,find/ftsfind.c:332-538,,,array error when access array data,can not fix it,N/A,N/A,N/A,N/A,,
find.e6680237,NGU0NDRiM2,pred.c:511-529,pred.c:513-513,buildcmd.h:49-49,,,Wrong condition,"diff --git a/find/pred.c b/find/pred.c
index e2e8dfb..364883f 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -510,7 +510,7 @@ pred_empty (const char *pathname, struct stat *stat_buf, struct predicate *pred_
 static bool
 record_exec_dir (struct exec_val *execp)
 {
-  if (!execp->wd_for_exec)
+  if (!execp->state.todo)
     {
       /* working directory not already known, so must be a *dir variant,
          and this must be the first arg we added.   However, this may
",1,1,Developer Fix,N/A,,
find.e6680237,NzBjMjQ0OT,find/pred.c:629-635,find/pred.c:538-620,lib/buildcmd.c:305-307,find/pred.c:2029-2125,,"The current file id is not getting changed  and we need to look in to that. I tried to debug this for a while, understood the bug a little bit but not able to patch it.",Was unable to patch this bug. I have a fair idea how to fix although,N/A,N/A,N/A,N/A,,
find.e6680237,OTRmYzA5OD,find/pred.c:513,find/pred.c:521,find/pred.c:524,,,"The check if (!execp->wd_for_exec) was true on the first directory and wd_for_exec was set correctly. On the next runs it was false, so wd_for_exec was not changed and command was executed in the first directory","diff --git a/find/pred.c b/find/pred.c
index e2e8dfb..f70c4fe 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -510,8 +510,6 @@ pred_empty (const char *pathname, struct stat *stat_buf, struct predicate *pred_
 static bool
 record_exec_dir (struct exec_val *execp)
 {
-  if (!execp->wd_for_exec)
-    {
       /* working directory not already known, so must be a *dir variant,
         and this must be the first arg we added.   However, this may
         be -execdir foo {} \; (i.e. not multiple).  */
@@ -519,12 +517,13 @@ record_exec_dir (struct exec_val *execp)
 
       /* Record the WD. */
       execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));
+
       execp->wd_for_exec->name = NULL;
       execp->wd_for_exec->desc = openat (state.cwd_dir_fd, ""."", O_RDONLY);
       if (execp->wd_for_exec->desc < 0)
        return false;
       set_cloexec_flag (execp->wd_for_exec->desc, true);
-    }
+    
   return true;
 }
",1,0,Regression,"Fix impacts inputs where execp->todo is not false s.t. the assertion fails. If execp->todo could never be false, the developer fix would substitute a superflous condition.",,
find.e6680237,MzBiYjQ4ZG,find/pred.c:510,find/utils.c:312,find/pred.c:510,,,Checking method of struct is having initialised was wrong. ,"diff --git a/find/pred.c b/find/pred.c
index e2e8dfb..165ea3f 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -510,7 +510,7 @@ pred_empty (const char *pathname, struct stat *stat_buf, struct predicate *pred_
 static bool
 record_exec_dir (struct exec_val *execp)
 {
-  if (!execp->wd_for_exec)
+  if (execp->wd_for_exec != initial_wd)
     {
       /* working directory not already known, so must be a *dir variant,
         and this must be the first arg we added.   However, this may
",1,0,Regression,"Fix impacts inputs where execp->todo is not false s.t. the assertion fails. If execp->todo could never be false, the developer fix would substitute a superflous condition.",,
find.e6680237,ZTBjYWY1Nj,find/pred.c:631,find/pred.c:549,find/pred.c:513,,,"When filling the exec structure for command to be run, working directory is being filled only if it was not filled before, so the command will be ran in the same directory for each find result - specifically, the first one.","diff --git a/find/pred.c b/find/pred.c
index e2e8dfb..3b158db 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -511,20 +511,20 @@ static bool
 record_exec_dir (struct exec_val *execp)
 {
   if (!execp->wd_for_exec)
-    {
-      /* working directory not already known, so must be a *dir variant,
-         and this must be the first arg we added.   However, this may
-         be -execdir foo {} \; (i.e. not multiple).  */
-      assert (!execp->state.todo);
-
-      /* Record the WD. */
-      execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));
-      execp->wd_for_exec->name = NULL;
-      execp->wd_for_exec->desc = openat (state.cwd_dir_fd, ""."", O_RDONLY);
-      if (execp->wd_for_exec->desc < 0)
-        return false;
-      set_cloexec_flag (execp->wd_for_exec->desc, true);
-    }
+      free(execp->wd_for_exec);
+
+  /* working directory not already known, so must be a *dir variant,
+   and this must be the first arg we added.   However, this may
+   be -execdir foo {} \; (i.e. not multiple).  */
+  assert (!execp->state.todo);
+
+  /* Record the WD. */
+  execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));
+  execp->wd_for_exec->name = NULL;
+  execp->wd_for_exec->desc = openat (state.cwd_dir_fd, ""."", O_RDONLY);
+  if (execp->wd_for_exec->desc < 0)
+    return false;
+  set_cloexec_flag (execp->wd_for_exec->desc, true);
   return true;
 }
 ",1,0,Regression,"Fix impacts inputs where execp->todo is not false s.t. the assertion fails. If execp->todo could never be false, the developer fix would substitute a superflous condition.",,
find.e6680237,MTk0NjE0Mj,pred.c:513,pred.c:523,pred.c:549,,,"Somebody forgot to close and free the file descriptor that was responsible for pointing child (pwd) to the necessary directory.

Somewhere between new_impl_pred_exec() and launch() resources taken for wd_for_exec (pred.c:523) must be released. So I've decided to quickly put close()/free() right after passing wd_for_exec to the child.","diff --git a/find/pred.c b/find/pred.c
index e2e8dfb..30441e6 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -2082,6 +2082,10 @@ launch (struct buildcmd_control *ctl, void *usercontext, int argc, char **argv)
        }
     }
 
+  close(execp->wd_for_exec->desc);
+  free(execp->wd_for_exec);
+  execp->wd_for_exec = NULL;
+
   if (WIFSIGNALED (execp->last_child_status))
     {
       error (0, 0, _(""%s terminated by signal %d""),
",1,0,Regression,"Fix impacts inputs where execp->todo is not false s.t. the assertion fails. If execp->todo could never be false, the developer fix would substitute a superflous condition.",,
find.e6680237,ODY3ODM5YW,pred.c:538-556,pred.c:513,pred.c:0,,,"The working directory is cached, even though it might change.","diff --git a/find/pred.c b/find/pred.c
index e2e8dfb..6588b61 100644
--- a/find/pred.c
+++ b/find/pred.c
@@ -519,12 +519,15 @@ record_exec_dir (struct exec_val *execp)
 
       /* Record the WD. */
       execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));
+    }
       execp->wd_for_exec->name = NULL;
+      if (execp->wd_for_exec->desc >= 0)
+        close (execp->wd_for_exec->desc);
       execp->wd_for_exec->desc = openat (state.cwd_dir_fd, ""."", O_RDONLY);
-      if (execp->wd_for_exec->desc < 0)
+        if (execp->wd_for_exec->desc < 0)
        return false;
       set_cloexec_flag (execp->wd_for_exec->desc, true);
-    }
+
   return true;
 }
",1,1,Different but Correct,N/A,,
find.ff248a20,ZDc4NDZjMm,find/find.c:1428,find/find.c:1428,find/find.c:1428,,,"The logic to ensure that the we do not follow into the same directory seems to be checking the inode of the symlink itself. If it followed into the symlink, it would realize that the two inodes are the same and would not drop in again.",N/a,N/A,N/A,N/A,N/A,,
find.ff248a20,NDY4NWM4M2,find/find.c:1461-1464,find/find.c:1664-1696,find/find.c:0,,,The two functions `process_path' and `process_dir' keep recursively call each other in the first two specified regions above. The reason seems to be that `subdirs_left' (defined on line 1570) never reaches zero.,---,N/A,N/A,N/A,N/A,,
find.ff248a20,ZTk0ZThkOD,find/find.c:1305,find/find.c:1429,find/find.c:1442,find/find.c:1567,find/find.c:1621,"expression in find/find.c:1429 never evaluated to ""true"" because value in dir_ids[i] always overwritten with uninitialized data;","diff --git a/find/find.c b/find/find.c
index 2c63677..180f206 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1572,6 +1572,7 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
   struct stat stat_buf;
   struct savedir_dirinfo *dirinfo;

+  stat_buf.st_ino = -1;
   subdirs_left = statp->st_nlink - 2; /* Account for name and ""."". */

   errno = 0;
@@ -1618,8 +1619,11 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
               * of what we think we should see later.
               * If there was no change, the assignments are a no-op.
               */
-             dir_ids[dir_curr].dev = stat_buf.st_dev;
-             dir_ids[dir_curr].ino = stat_buf.st_ino;
+             /* check if stat_buf initialized */
+             if (stat_buf.st_ino != -1) {
+                dir_ids[dir_curr].dev = stat_buf.st_dev;
+                dir_ids[dir_curr].ino = stat_buf.st_ino;
+             }
              break;

            case SafeChdirFailWouldBeUnableToReturn:
",1,1,Different but Correct,N/A,,
find.ff248a20,YTA2MTE4ND,find/find.c:1428-1434,find/find.c:1432-1443,find/find.c:1621-1622,,,"dir_ids[dir_curr] array is used to track directories which were already seen on current branch.

at find/find.c:1428-1434 current file is checked to be already traversed through

at find/find.c:1432-1443 current file is added to the list as being traversed currently

at find/find.c:1621-1622 that data is overwritten with some other value","diff --git a/find/find.c b/find/find.c
index 2c63677..862657a 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1618,8 +1618,6 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
               * of what we think we should see later.
               * If there was no change, the assignments are a no-op.
               */
-             dir_ids[dir_curr].dev = stat_buf.st_dev;
-             dir_ids[dir_curr].ino = stat_buf.st_ino;
              break;
       
            case SafeChdirFailWouldBeUnableToReturn:
",1,0,Regression,Fix impacts inputs where statbuf is correctly overridden,,
find.ff248a20,OTcyZjg1Mz,find/find.c:1428-1434,find/find.c:1428-1443,find/find.c:1471-1471,find/find.c:1621-1622,,"Array of values we store to detect loop condition at section 2 is corrupted due to wrong index management at section 4. 
At this array we keep track of the entries already visited to detect loop condition and once inserted the link entry, section 4 corrupts it making it impossible to detect at comparison","--- a/find/find.c
+++ b/find/find.c
@@ -1460,7 +1460,7 @@ process_path (char *pathname, char *name, boolean leaf, char *parent,
   
   if (state.stop_at_current_level == false)
     /* Scan directory on disk. */
-    process_dir (pathname, name, strlen (pathname), &stat_buf, parent);
+    process_dir (pathname, name, strlen (pathname), &stat_buf, parent);   
 
   if (options.do_dir_first == false && state.curdepth >= options.mindepth)
     {
@@ -1468,6 +1468,7 @@ process_path (char *pathname, char *name, boolean leaf, char *parent,
       apply_predicate (pathname, &stat_buf, eval_tree);
     }
 
+  
   dir_curr--;
 
   return 1;
@@ -1618,8 +1619,8 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
               * of what we think we should see later.
               * If there was no change, the assignments are a no-op.
               */
-             dir_ids[dir_curr].dev = stat_buf.st_dev;
-             dir_ids[dir_curr].ino = stat_buf.st_ino;
+             dir_ids[dir_curr+1].dev = stat_buf.st_dev;
+             dir_ids[dir_curr+1].ino = stat_buf.st_ino;
              break;",1,0,Regression,Fix impacts inputs where statbuf is correctly overridden,,
find.ff248a20,ZmZkMWM5OG,find/find.c:1611,find/find.c:1426-1434,find/find.c:1614-1623,find/find.c:1138-1150,,"The program supports two kind of system libraries and use #ifdef to choose the correct one, see find/find.c:1138-1150. After safely_chdir() at find/find.c:1611, one kind of system call needs some postcalculations based on the value of variable ""stat_buf"", see find/find.c:1614-1623, but this should not be done for the other one becuase variable ""stat_buf"" does not have the correct value. Because of missing #ifdef, the wrong value of ""stat_buf"" is used and then the lcurrent directoty is not correctly remebered. Finaly, the loop in find/find.c:1426-1434 is not able to detect symlink to the already visited directory.
","diff --git a/find/find.c b/find/find.c
index 2c63677..f70e5dd 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1618,8 +1618,18 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
                * of what we think we should see later.
                * If there was no change, the assignments are a no-op.
                */
+/* MEOLIC: BUG FIXING */
+#if defined O_NOFOLLOW  
+          if (options.open_nofollow_available){}
+          else {
+                dir_ids[dir_curr].dev = stat_buf.st_dev;
+                dir_ids[dir_curr].ino = stat_buf.st_ino;
+          }
+#else
               dir_ids[dir_curr].dev = stat_buf.st_dev;
               dir_ids[dir_curr].ino = stat_buf.st_ino;
+#endif
+/* MEOLIC: END OF FIX */
               break;
       
             case SafeChdirFailWouldBeUnableToReturn:
",1,0,Regression,Fix impacts inputs where statbuf is correctly overridden,,
find.ff248a20,NDM5MjVmOT,find/find.c:1572,find/find.c:1428-1434,find/find.c:1442-1443,find/find.c:1621-1622,,"Program uses (inode, dev) pairs chain to identify path already visited (find/find.c:1442-1443). It performs check against new directory visited to prevent loops (find/find.c:1428-1434). Value of struct stat stat_buf (find/find.c:1572) used to overwrite (inode, dev) pair (find/find.c:1621-1622) but stat_buf is not initialized before this point, so it contains garbage data. That is why replaced values can not be used to identify path already visited.","diff --git a/find/find.c b/find/find.c                                                                                                                                                                                                       
index 2c63677..5882764 100644                                                                                                                                                                                                                
--- a/find/find.c                                                                                                                                                                                                                            
+++ b/find/find.c                                                                                                                                                                                                                            
@@ -1569,7 +1569,7 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *                                                                                                                                       
   char *name_space;            /* Names of files in PATHNAME. */                                                                                                                                                                            
   int subdirs_left;            /* Number of unexamined subdirs in PATHNAME. */                                                                                                                                                              
   int idx;                     /* Which entry are we on? */                                                                                                                                                                                 
-  struct stat stat_buf;                                                                                                                                                                                                                     
+  struct stat stat_buf = *statp;                                                                                                                                                                                                            
   struct savedir_dirinfo *dirinfo;                                                                                                                                                                                                          
                                                                                                                                                                                                                                             
   subdirs_left = statp->st_nlink - 2; /* Account for name and ""."". */     ",1,0,Regression,statbuf pointing to incorrect structure,,
find.ff248a20,NGU0NDRiM2,find/find.c:1442-1443,find/find.c:1461-1463,find/find.c:1621-1622,,,"In process_path() function we check for already passed paths and put new dirs to dir_ids, but in process_dir() we reassign latest dir_ids.","diff --git a/find/find.c b/find/find.c
index 2c63677..73e6300 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1459,8 +1459,12 @@ process_path (char *pathname, char *name, boolean leaf, char *parent,
 #endif /* DEBUG */
   
   if (state.stop_at_current_level == false)
+  {
     /* Scan directory on disk. */
+    dir_curr++;
     process_dir (pathname, name, strlen (pathname), &stat_buf, parent);
+    dir_curr--;
+  }
 
   if (options.do_dir_first == false && state.curdepth >= options.mindepth)
     {
",1,0,Incorrect workaround,curr_dir is not supposed to be increased,,
find.ff248a20,NzBjMjQ0OT,find/find.c:1427-1435,find/find.c:1462-1464,find/find.c:1610-1624,,,"After, analyzing for quite some time , I figured out that the issue_loop_warning() was not getting called. 
The issue was that a call to stat() was missing in the process_dir()","--- find.c  2016-05-11 12:05:27.000000000 +0530
+++ find_new.c  2016-05-29 05:12:21.527460887 +0530
@@ -1618,8 +1618,11 @@
           * of what we think we should see later.
           * If there was no change, the assignments are a no-op.
           */
-         dir_ids[dir_curr].dev = stat_buf.st_dev;
-         dir_ids[dir_curr].ino = stat_buf.st_ino;
+          if (0 == stat(""."", &stat_buf))
+          {    
+           dir_ids[dir_curr].dev = stat_buf.st_dev;
+           dir_ids[dir_curr].ino = stat_buf.st_ino;
+          }
          break;

        case SafeChdirFailWouldBeUnableToReturn:
",1,1,Different but Correct,N/A,,
find.ff248a20,ZTBjYWY1Nj,find/find.c:1701,find/find.c:1463,find/find.c:1261,,,"When recursing to subdirectories (region 1), there is no checking for symlinks at all (along with funny source code comment about weird filesystems ""which don't have Unix-like directory link counts"").","diff --git a/find/find.c b/find/find.c
index 2c63677..d97d5c2 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1697,8 +1697,19 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
           else
             {
               /* There might be weird (e.g., CD-ROM or MS-DOS) filesystems
-                 mounted, which don't have Unix-like directory link counts. */
-              process_path (cur_path, cur_name, false, pathname, mode);
+                 mounted, which don't have Unix-like directory link counts.
+               */
+                if (mode && S_ISLNK(mode))
+                {
+                  int olddepth = options.maxdepth; /* HACK to make descent stop */
+                  options.maxdepth = 1;
+                  state.curdepth = options.maxdepth;
+                  issue_loop_warning(cur_name, cur_path, 0);
+                  process_path (cur_path, cur_name, false, pathname, mode);
+                  options.maxdepth = olddepth;
+                }
+                else
+                  process_path (cur_path, cur_name, false, pathname, mode);
             }
           
           state.curdepth--;",1,0,Regression,Fix impacts all searches with more depth required,,
find.ff248a20,MTk0NjE0Mj,find.c:1442,find.c:1621,find.c:1123,,,"Already filled dir_ids at find.c:1442 gets overwritten by uninitialized values in process_dir() at find.c:1611.
safely_chdir() uses safely_chdir_nofollow() which, in turn, does not do any calls to stat() and just returns at find.c:1123.","diff --git a/find/find.c b/find/find.c
index 2c63677..4df1fb5 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1569,7 +1569,7 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
   char *name_space;            /* Names of files in PATHNAME. */
   int subdirs_left;            /* Number of unexamined subdirs in PATHNAME. */
   int idx;                     /* Which entry are we on? */
-  struct stat stat_buf;
+  struct stat stat_buf = {};
   struct savedir_dirinfo *dirinfo;
   
   subdirs_left = statp->st_nlink - 2; /* Account for name and ""."". */
@@ -1612,6 +1612,8 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
          switch (status)
            {
            case SafeChdirOK:
+             if (stat_buf.st_dev == 0 && stat_buf.st_ino == 0)
+               break;
              /* If there had been a change but wd_sanity_check()
               * accepted it, we need to accept that on the 
               * way back up as well, so modify our record 
",1,1,Different but Correct,N/A,,
find.ff248a20,ODY3ODM5YW,find.c:1444,find.c:1623,find.c:1634,,,"While processing the path we set the inode and dev at find.c:1444
Then while processing the directory we check whether it is safe to change into the directory. If yes, we overwrite the indode and dev in the dir_ids array with the inode of the symlink.
","diff --git a/find/find.c b/find/find.c
index 2c63677..e42b76f 100644
--- a/find/find.c
+++ b/find/find.c
@@ -1570,6 +1570,7 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
   int subdirs_left;      /* Number of unexamined subdirs in PATHNAME. */
   int idx;             /* Which entry are we on? */
   struct stat stat_buf;
+  stat_buf.st_ino = -1;
   struct savedir_dirinfo *dirinfo;
   
   subdirs_left = statp->st_nlink - 2; /* Account for name and ""."". */
@@ -1618,8 +1619,10 @@ process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *
         * of what we think we should see later.
         * If there was no change, the assignments are a no-op.
         */
-       dir_ids[dir_curr].dev = stat_buf.st_dev;
-       dir_ids[dir_curr].ino = stat_buf.st_ino;
+        if (stat_buf.st_ino != -1) {
+          dir_ids[dir_curr].dev = stat_buf.st_dev;
+          dir_ids[dir_curr].ino = stat_buf.st_ino;
+        }
        break;
       
      case SafeChdirFailWouldBeUnableToReturn:
",1,1,Different but Correct,N/A,,
grep.2be0c659,OWUwOTY1N2,src/grep.c:1060-1062,src/search.c:382-396,src/search.c:388,,,"with -i mode, grep lowers the source string to match it over lowered pattern. The character 'I with dot' lowered takes 1 byte less in UTF-8 (1 byte vs 2 bytes), but no function in the sources is aware of this possiblity.","diff --git a/src/grep.c b/src/grep.c
index 2dc3ee9..0223f99 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1059,7 +1059,11 @@ static EXECUTE_RET do_execute EXECUTE_ARGS
 
       result = execute (line_buf, line_next - line_buf, match_size, start_ptr);
       if (result != (size_t) -1)
-       return (line_buf - buf) + result;
+        {
+          if(match_size)
+            *match_size = line_next - line_buf;
+          return (line_buf - buf) + result;
+        }
     }
 
   return (size_t) -1;
",1,0,Regression,Only match should be returned,,
grep.2be0c659,MjYyZjkxNm,src/grep.c:1829-2284,src/grep.c:1258-1375,src/grep.c:1127-1255,src/grep.c:891-936,src/search.c:355-564,"When we convert chars to lower case to do -i option the length is modified and we continue using the original length of the UTF-8 input text, this way we obtain longer output strings and buffers with rubbish that causes the issue"," --- a/src/grep.c
+++ b/src/grep.c
@@ -1087,7 +1087,9 @@ grepbuf (char const *beg, char const *lim)
       if (b == lim)
        break;
       if (!out_invert)
-       {
+       { 
+    // use old limit not new one
+    endp = lim;
          prtext (b, endp, (int *) 0);
          nlines++;
           outleft--;",1,0,Regression,Only match should be returned,,
grep.2be0c659,YmI4MGM3ND,src/grep.c:1081,src/grep.c:1060,src/search.c:384-398,,,"do_execute implementation returns match_size after source string lowercased, and in case wide char string it less than original string","diff --git a/src/search.c b/src/search.c
index 1c9272e..a91fcb5 100644
--- a/src/search.c
+++ b/src/search.c
@@ -377,6 +377,8 @@ EXECUTE_FCT(EGexecute)
   int backref, start, len, best_len;
   struct kwsmatch kwsm;
   size_t i, ret_val;
+  size_t orig_size = size;
+
 #ifdef MBS_SUPPORT
   char *mb_properties = NULL;
   if (MB_CUR_MAX > 1)
@@ -558,8 +560,12 @@ EXECUTE_FCT(EGexecute)
   ret_val = beg - buf;
  out:
 #ifdef MBS_SUPPORT
-  if (MB_CUR_MAX > 1)
+  if (MB_CUR_MAX > 1) {
     free (mb_properties);
+    if (len && match_icase) {
+       *match_size = orig_size;
+    }
+  }
 #endif /* MBS_SUPPORT */
   return ret_val;
 }
",1,0,Regression,Only match should be returned,,
grep.2be0c659,ZGU4Yjc1ZG,src/grep.c:1081,src/search.c:626,src/search.c:86-140,,,"Function grepbuf() calls function do_execute() until the complete buffer is checked, src/grep.c:1081. In the case of UTF-8 and -i,  function do_execute() returns wrong size of the matched text. It reports number of bytes after the transformation to lowercase, see src/search.c:626 and src/search.c:86-140, but the reported number could be different as the number of bytes of the original text. When necessary, this should be adapted after the call of function do_execute()  and this is missing.","diff --git a/src/grep.c b/src/grep.c
index 2dc3ee9..760f990 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1083,6 +1083,35 @@ grepbuf (char const *beg, char const *lim)
     {
       char const *b = p + match_offset;
       char const *endp = b + match_size;
+
+/* MEOLIC: BUG FIXING */
+#ifdef MBS_SUPPORT
+      if (MB_CUR_MAX > 1)
+      {
+        if (match_icase) {
+          /* check a mapping between the original and the converted letters */
+          /* adjust endp if necessary */
+          char *p1 = p;
+          char p2[MB_CUR_MAX];
+          size_t length1,length2,length3;
+          wchar_t onechar;
+          mbstate_t mbs1,mbs2;
+          memset(&mbs1,0,sizeof(mbs1));
+          memset(&mbs2,0,sizeof(mbs2));
+          length3 = 0;
+          while (length3 != match_size) {
+            length1 = mbrtowc(&onechar,p1,lim-p1,&mbs1);
+            p1+=length1;
+            length2 = wcrtomb((char *)&p2,towlower((wint_t)onechar),&mbs2);
+            length3 += length2;
+            endp = endp + length1 - length2;
+          }
+        }
+      }
+#endif /* MBS_SUPPORT */
+/* MEOLIC: END OF FIX */
+
+
       /* Avoid matching the empty line at the end of the buffer. */
       if (b == lim)
         break;
",1,1,Different but Correct,N/A,,
grep.2be0c659,ZWM2ODBmOG,grep/src/search.c:384-392,grep/src/search.c:555-557,grep/src/grep.c:1085,grep/src/grep.c:926,,"For case insensitive search, input text case has to be lowered (grep/src/search.c:384-392). After lowering case, 8-bit characters are converted to unicode multibyte characters. After finding a match, function returns length of match (grep/src/search.c:555-557) but it corresponding to lowercase multibyte string, not original string. This value used to calculate end point of buffer to print out (grep/src/grep.c:1085). So result string printed out having wrong size, usually larger than ough to be (grep/src/grep.c:926). ","diff --git a/src/grep.c b/src/grep.c
index 2dc3ee9..a3ed458 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1059,7 +1059,10 @@ static EXECUTE_RET do_execute EXECUTE_ARGS
 
       result = execute (line_buf, line_next - line_buf, match_size, start_ptr);
       if (result != (size_t) -1)
-        return (line_buf - buf) + result;
+        {
+          *match_size = line_next - line_buf;
+          return (line_buf - buf) + result;
+        }
     }
 
   return (size_t) -1;",1,0,Regression,Only match should be returned,,
grep.2be0c659,OWMzNDk3N2,search.c:382-396,search.c:112-112,search.c:131-131,,,"When UTF char converting to lower case its size may change, but this is not handle in code.
I found that code in 2 and 3 regions can get different sizes of chars, then I apply this knowledge to region 1.","diff --git a/src/search.c b/src/search.c
index 1c9272e..26f4df4 100644
--- a/src/search.c
+++ b/src/search.c
@@ -378,6 +378,7 @@ EXECUTE_FCT(EGexecute)
   struct kwsmatch kwsm;
   size_t i, ret_val;
 #ifdef MBS_SUPPORT
+  size_t case_size = size;
   char *mb_properties = NULL;
   if (MB_CUR_MAX > 1)
     {
@@ -385,14 +386,14 @@ EXECUTE_FCT(EGexecute)
         {
           /* mbtolower adds a NUL byte at the end.  That will provide
              space for the sentinel byte dfaexec may add.  */
-          char *case_buf = mbtolower (buf, &size);
+          char *case_buf = mbtolower (buf, &case_size);
           if (start_ptr)
             start_ptr = case_buf + (start_ptr - buf);
           buf = case_buf;
         }
 
       if (kwset)
-        mb_properties = check_multibyte_string(buf, size);
+        mb_properties = check_multibyte_string(buf, case_size);
     }
 #endif /* MBS_SUPPORT */
 
",1,0,Regression,Always fail to match multibyte characters,,
grep.2be0c659,ZmU3ZTExOW,src/grep.c:2004,src/search.c:87-140,src/search.c:180,,,only few cases were taken care of. It may possible that other case come so proper use of if condition was not done.,"diff --git a/src/search.c b/src/search.c
index 1c9272e..b570616 100644
--- a/src/search.c
+++ b/src/search.c
@@ -116,7 +116,7 @@ mbtolower (const char *beg, size_t *n)
           p = out + outlen;
         }

-      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
+      if (mbclen == (size_t) -1 || mbclen <= (size_t) -2 || mbclen == 0)
         {
           /* An invalid sequence, or a truncated multi-octet character.
              We treat it as a single-octet character.  */
",1,0,Regression,Always fail to match multibyte characters,,
grep.2be0c659,MGFkYmExOT,search.c:388,search.c:112,search.c:131,,,"mbtolower() returns length of the ""lower-cased"" string here search.c:388. But lowercase character sometimes occupy more bytes than original (search.c:112 and search.c:131).",none,N/A,N/A,N/A,N/A,,
grep.2be0c659,MDUyYzIwMz,search.c:387-393,grep.c:1081-1114,nother.c:0,,,"After changing the string to lower case, the string is shorter. Thus the returned match_size is wrong because it uses the match len of the lower case string.","diff --git a/src/search.c b/src/search.c
index 1c9272e..7114e55 100644
--- a/src/search.c
+++ b/src/search.c
@@ -377,6 +377,7 @@ EXECUTE_FCT(EGexecute)
   int backref, start, len, best_len;
   struct kwsmatch kwsm;
   size_t i, ret_val;
+  size_t diff_size = 0;
 #ifdef MBS_SUPPORT
   char *mb_properties = NULL;
   if (MB_CUR_MAX > 1)
@@ -385,7 +386,9 @@ EXECUTE_FCT(EGexecute)
         {
           /* mbtolower adds a NUL byte at the end.  That will provide
              space for the sentinel byte dfaexec may add.  */
+          size_t old = size;
           char *case_buf = mbtolower (buf, &size);
+          diff_size = old - size;
           if (start_ptr)
             start_ptr = case_buf + (start_ptr - buf);
           buf = case_buf;
@@ -554,7 +557,7 @@ EXECUTE_FCT(EGexecute)
  success:
   len = end - beg;
  success_in_len:
-  *match_size = len;
+  *match_size = len  + diff_size;
   ret_val = beg - buf;
  out:
 #ifdef MBS_SUPPORT
",1,0,Incomplete Fix,"For files that has more multibyte characters than given in the match, grep reports longer matches than needed.",,
grep.3220317a,OGRmNDYyYW,grep/grep.c:1856-1857,grep/grep.h:70,grep/grep.c:2006,,,case sensitive local wrongly set,not done,N/A,N/A,N/A,N/A,,
grep.3220317a,OWUwOTY1N2,grep/dfa.c:697-726,grep/dfa.c:697,grep/dfa.c:244-276,,,"the setbit_case_fold function was called at grep/dfa.c:697 even if the character is multibyte (i.e. outside of char type). in this case, it is called with -1 value (0xFFFFFFFF) which falls outside of allowed borders","diff --git a/src/dfa.c b/src/dfa.c
index 3b0d861..13dbbdc 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -694,7 +694,6 @@ parse_bracket_exp (void)
           continue;
         }
 
-      setbit_case_fold (c, ccl);
 #ifdef MBS_SUPPORT
       /* Build normal characters.  */
       if (MB_CUR_MAX > 1)
@@ -709,6 +708,8 @@ parse_bracket_exp (void)
                                        work_mbc->nchars + 1);
                   work_mbc->chars[work_mbc->nchars++] = wc;
                 }
+              else
+                setbit_case_fold (c, ccl);
 #ifdef GREP
               continue;
 #else
@@ -722,6 +723,8 @@ parse_bracket_exp (void)
                                    work_mbc->nchars + 1);
               work_mbc->chars[work_mbc->nchars++] = wc;
             }
+          else
+            setbit_case_fold (c, ccl);
 #endif
         }
     }
",1,0,Regression,setbit_case_fold is supposed to be called in the multibyte case.,,
grep.3220317a,YmI4MGM3ND,src/dfa.c:168,src/dfa.c:274,src/dfa.c:697,src/dfa.c:1053,src/dfa.c:1371,"in case ""setbit"" function receives EOF as first argument (b variable), app crashes because of b used to calculate offset in charclass. in case of b will be EOF, offset will be invalid; Not sure if this a core reason eigher..","diff --git a/src/dfa.c b/src/dfa.c
index 3b0d861..30f0757 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -269,7 +269,7 @@ setbit_case_fold (unsigned b, charclass c)
   else
     {
 #ifdef MBS_SUPPORT
-      if (wctob ((unsigned char)b) == b)
+      if (wctob ((unsigned char)b) == b && b != EOF)
 #endif
         setbit (b, c);
     }
@@ -693,8 +693,7 @@ parse_bracket_exp (void)
           FETCH_WC(c1, wc1, _(""unbalanced [""));
          continue;
        }
-
-      setbit_case_fold (c, ccl);
+       setbit_case_fold (c, ccl);
 #ifdef MBS_SUPPORT
       /* Build normal characters.  */
       if (MB_CUR_MAX > 1)
",1,0,Treating the Symptom,This does not address the root cause but the symptom,,
grep.3220317a,MjYyZjkxNm,src/dfa.c:697-698,src/dfa.c:246-275,src/dfa.c:168-168,,,Invalid use of memory address when indexing charclass array at section 1 that causes a Segmentation fault at  section 3 (Section 2 is justa a passing function),"diff --git a/src/dfa.c b/src/dfa.c
index 3b0d861..691da2e 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -694,7 +694,7 @@ parse_bracket_exp (void)
          continue;
        }
 
-      setbit_case_fold (c, ccl);
+      setbit_case_fold (0, /*c,*/ ccl);
 #ifdef MBS_SUPPORT
       /* Build normal characters.  */
       if (MB_CUR_MAX > 1)",1,0,Treating the Symptom,No segmentation fault but incorrect behavior,,
grep.3220317a,ZGU4Yjc1ZG,src/dfa.c:1053,src/dfa.c:498,src/dfa.c:697,,,"The content of brackets is parsed in parse_bracket_exp(), invoked at src/dfa.c:1053.  Character are read within a macro FETCH_WC. In this macro, for ascii characters, variables c and wc both get assigned a current characters, whilst for wide characters variable c gets assigned value -1. Aterwards, at src/dfa.c:697, internal structure ccl is updated using function setbit_case_fold(). But, this internal structure is intended only for use with valid ascii characters and thus we get segmentation fault when trying to use it with c = -1 (this happens for wide characters).","diff --git a/src/dfa.c b/src/dfa.c
index 3b0d861..648b6bd 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -694,7 +694,7 @@ parse_bracket_exp (void)
           continue;
         }
 
-      setbit_case_fold (c, ccl);
+      if (c != EOF) setbit_case_fold (c, ccl); /* MEOLIC: BUG FIXING */
 #ifdef MBS_SUPPORT
       /* Build normal characters.  */
       if (MB_CUR_MAX > 1)
",1,0,Treating the Symptom,This does not address the root cause but the symptom,,
grep.3220317a,ZWM2ODBmOG,grep/src/dfa.c:168,grep/src/dfa.c:271-274,grep/src/dfa.c:697,grep/src/dfa.c:363,,"While parsing unicode expression, program converting wide char to single byte char (grep/src/dfa.c:363). Function wctob() used for that returns -1 when such conversion not available. Program using returned value to set bit corresponding to found character (grep/src/dfa.c:697). Function setbit_case_fold() seems have guard code for that case but it actually never work due wctob(-1) returns -1 anyway. Using -1 value at grep/src/dfa.c:168 is invalid and causing segfault. ","diff --git a/src/dfa.c b/src/dfa.c
index 3b0d861..96f9a2a 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -694,7 +694,7 @@ parse_bracket_exp (void)
           continue;
         }
 
-      setbit_case_fold (c, ccl);
+      setbit_case_fold (wc, ccl);
 #ifdef MBS_SUPPORT
       /* Build normal characters.  */
       if (MB_CUR_MAX > 1)",1,1,Developer Fix,N/A,,
grep.3220317a,OWMzNDk3N2,dfa.c:168-168,dfa.c:458-748,dfa.c:341-366,,,"Do not transform multibyte wchar to int in region #3.
","diff --git a/gnulib b/gnulib
--- a/gnulib
+++ b/gnulib
@@ -1 +1 @@
-Subproject commit aadf332a5c5f209affd38c35b4e9faaa8a0adecb
+Subproject commit aadf332a5c5f209affd38c35b4e9faaa8a0adecb-dirty
diff --git a/src/dfa.c b/src/dfa.c
index 3b0d861..1e00de9 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -335,6 +335,39 @@ static unsigned char const *buf_begin;	/* reference to begin in dfaexec().  */
 static unsigned char const *buf_end;	/* reference to end in dfaexec().  */
 #endif /* MBS_SUPPORT  */
 
+union short_union
+{
+	short int short_int;
+	unsigned short int short_uint;
+	char bytes[2];
+};
+
+int
+wctoint (wint_t wc)
+{
+  char buf[64];
+  int count = wctomb (buf, wc);
+
+  if (!(MB_CUR_MAX <= sizeof (buf)))
+  {
+    abort ();
+  }
+  if (count == 1)
+  {
+    return (unsigned char) buf[0];
+  }
+  else if(count == 2)
+  {
+  	  union short_union temp;
+  	  temp.bytes[0] = buf[1];
+  	  temp.bytes[1] = buf[0];
+  	  return temp.short_uint;
+  }
+  else
+  {
+    return EOF;
+  }
+}
 
 #ifdef MBS_SUPPORT
 /* Note that characters become unsigned here. */
@@ -360,7 +393,7 @@ static unsigned char const *buf_end;	/* reference to end in dfaexec().  */
           {					\
             lexptr += cur_mb_len;		\
             lexleft -= cur_mb_len;		\
-            (c) = wctob(wc);			\
+            (c) = wctoint(wc);			\
           }					\
       }						\
   } while(0)
",1,0,Incomplete Fix,Test case still fails,,
grep.3220317a,NTM3Y2E1MW,src/dfa.c:168-170,src/dfa.c:280-282,src/dfa.c:696-699,src/dfa.c:543-545,,The arguments to the setbit_case_fold() method was incorrect and hence the setbit() was computing a value which was out of bounds and hence a bus error was being generated.,"--- dfa.c   2016-06-10 06:12:06.529932285 +0530
+++ dfa_copy.c  2016-06-10 06:12:51.605934436 +0530
@@ -541,7 +541,7 @@
          str[len] = '\0';

               /* Fetch bracket.  */
-         FETCH (c, _(""unbalanced [""));
+         FETCH_WC (c,wc, _(""unbalanced [""));
          if (c1 == ':')
        /* build character class.  */
        {
@@ -694,7 +694,7 @@
      continue;
    }

-      setbit_case_fold (c, ccl);
+      setbit_case_fold (wc, ccl);
 #ifdef MBS_SUPPORT
       /* Build normal characters.  */
       if (MB_CUR_MAX > 1)",1,1,Developer Fix,N/A,,
grep.3220317a,MjYyYzZkN2,src/dfa.c:168,src/dfa.c:274,src/dfa.h:43,,,The root cause was setting bit for character class (region 1) in case of multibyte character (region 2) lead to overflow - the argument was -1 and then casted to unsigned int; while size of character class array is only 32 bytes (region 3).,"diff --git a/src/dfa.c b/src/dfa.c
index 3b0d861..3cfc6b9 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -251,9 +251,9 @@ setbit_case_fold (unsigned b, charclass c)
         {
           wint_t b1 = iswupper(b) ? towlower(b) : b;
           wint_t b2 = iswlower(b) ? towupper(b) : b;
-          if (wctob ((unsigned char)b1) == b1)
+          if (wctob ((unsigned char)b1) == b1 && b != EOF)
             setbit (b1, c);
-          if (b2 != b1 && wctob ((unsigned char)b2) == b2)
+          if (b2 != b1 && wctob ((unsigned char)b2) == b2 && b != EOF)
             setbit (b2, c);
         }
       else
@@ -269,7 +269,7 @@ setbit_case_fold (unsigned b, charclass c)
   else
     {
 #ifdef MBS_SUPPORT
-      if (wctob ((unsigned char)b) == b)
+      if (wctob ((unsigned char)b) == b && b != EOF)
 #endif
         setbit (b, c);
     }
",1,0,Treating the Symptom,This does not address the root cause but the symptom,,
grep.3220317a,MGFkYmExOT,dfa.c:498,dfa.c:697,dfa.c:166,,,"FETCH_WC at dfa.c:498 returns -1 because wc cannot be represented as one byte. c is then passed to setbit_case_fold() as unsigned, thus causing the segfault in setbit() dfa.c:166.","diff --git a/src/dfa.c b/src/dfa.c
index 3b0d861..e3fa1af 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -694,7 +694,9 @@ parse_bracket_exp (void)
          continue;
        }
 
-      setbit_case_fold (c, ccl);
+      if(c != EOF)
+        setbit_case_fold (c, ccl);
+
 #ifdef MBS_SUPPORT
       /* Build normal characters.  */
       if (MB_CUR_MAX > 1)
",1,0,Treating the Symptom,This does not address the root cause but the symptom,,
grep.3220317a,MDUyYzIwMz,dfa.c:697-698,dfa.c:245,dfa.c:168,dfa.c:498,,Oob access at dfa.c:168 due to EOF at dfa.c:498,"diff --git a/src/dfa.c b/src/dfa.c
index 3b0d861..87711b2 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -694,7 +694,8 @@ parse_bracket_exp (void)
           continue;
         }
 
-      setbit_case_fold (c, ccl);
+      if (c != EOF)
+        setbit_case_fold (c, ccl);
 #ifdef MBS_SUPPORT
       /* Build normal characters.  */
       if (MB_CUR_MAX > 1)

",1,0,Treating the Symptom,This does not address the root cause but the symptom,,
grep.3c3bdace,OWUwOTY1N2,src/dfa.c:1728,src/dfa.c:1917,src/dfa.c:1685-1918,,,"in dfaanalyze function, buffer allocated for merging position_sets is too short","diff --git a/src/dfa.c b/src/dfa.c
index d1d7f25..c523d46 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -1725,7 +1725,7 @@ dfaanalyze (struct dfa *d, int searchflag)
   MALLOC(nalloc, int, d->tindex);
   for (i = 0; i < d->tindex; ++i)
     nalloc[i] = 0;
-  MALLOC(merged.elems, position, d->nleaves);
+  MALLOC(merged.elems, position, d->nleaves * 2);
 
   CALLOC(d->follows, position_set, d->tindex);
 
",1,1,First Developer Fix,N/A,,
grep.3c3bdace,MjYyZjkxNm,src/dfa.c:1689-1923,src/dfa.c:1462-1495,src/dfa.c:1572-1634,,,"The coredump is generated because we are trying to deallocate a region of memory whose size is higher that initial size allocated with malloc(). This normally is due to we are indexing memory out of the initial size.
At region 1 we allocate it and at regions 2 and 3 we index the different positions.
At region 3 we are not indexing it OK, because we do not reset nelem value","diff --git a/src/dfa.c b/src/dfa.c
index d1d7f25..d760d57 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -1618,6 +1618,9 @@ epsclosure (position_set *s, struct dfa const *d)
          default:
            break;
          }
+  
+  s->nelem = 0;
+
        for (j = 0; j < d->follows[old.index].nelem; ++j)
          {",1,0,Regression,Always overrides the first element instead during insert.,,
grep.3c3bdace,YmI4MGM3ND,src/search.c:271,src/dfa.c:3002-3005,src/dfa.c:1917,,,"if case ""*"" (star) in pattern, ""free"" call crashes the app with SIGSEGV/SIGABRT. 
couldn't find why this happened",N/A - didn't fixed an error,N/A,N/A,N/A,N/A,,
grep.3c3bdace,ZGU4Yjc1ZG,src/dfa.c:1885-1889,src/dfa.c:1419-1427,src/dfa.c:1591,src/dfa.c:1621-1625,,"At src/dfa.c:1885-1889, structure ""d->follows[i]"" is copied to temporal structure ""merged"", then epsclosure() is called for this temporal structure and then its content is copied back to d->follows[i]. I found 2 problems inside this operations. First, ""d->follows[i]"" may need more memory as currently reserved for ""merged"" and because function copy() does not serve this, see src/dfa.c:1419-1427, the program should extend memory block used for ""merged"" when necessary. But, then the second problem arises. Function epsclosure() may delete and insert elements and it may insert more elements as it deletes, see src/dfa.c:1591 and src/dfa.c:1624. Thus, if this problem is not already considered during the previous extension of memory block for ""merged"" it has to be addressed at least before src/dfa.c:1621-1625.","diff --git a/src/dfa.c b/src/dfa.c
index d1d7f25..fcba2f1 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -1574,7 +1574,8 @@ epsclosure (position_set *s, struct dfa const *d)
   int i, j;
   char *visited;
   position p, old;
-
+  int snelem = s->nelem; /* MEOLIC: BUG FIXING */
+  
   CALLOC(visited, char, d->tindex);
 
   for (i = 0; i < s->nelem; ++i)
@@ -1618,6 +1619,8 @@ epsclosure (position_set *s, struct dfa const *d)
           default:
             break;
           }
+    if (s->nelem + d->follows[old.index].nelem > snelem)
+          REALLOC(s->elems, position, snelem=(s->nelem+d->follows[old.index].nelem)); /* MEOLIC: BUG FIXING */
         for (j = 0; j < d->follows[old.index].nelem; ++j)
           {
             p.index = d->follows[old.index].elems[j].index;
@@ -1882,6 +1885,8 @@ dfaanalyze (struct dfa *d, int searchflag)
           }
         putc('\n', stderr);
 #endif
+        if (merged.nelem < d->follows[i].nelem)
+          REALLOC(merged.elems, position, d->follows[i].nelem); /* MEOLIC: BUG FIXING */
         copy(&d->follows[i], &merged);
         epsclosure(&merged, d);
         if (d->follows[i].nelem < merged.nelem)
",1,1,Different but Correct,N/A,,
grep.3c3bdace,ZWM2ODBmOG,grep/src/dfa.c:1728,grep/src/dfa.c:1453,grep/src/dfa.c:1494,grep/src/dfa.c:1455,grep/src/dfa.c:11917,"Memory allocated for merged.elems array (grep/src/dfa.c:1728) but number of elements inserted to it can grow twice to array size allocated (grep/src/dfa.c:1455). Memory corruption caused by accessing elements out of array boundary (grep/src/dfa.c:1453), (grep/src/dfa.c:1494) leads to segfault when memory frees (grep/src/dfa.c:11917).","diff --git a/src/dfa.c b/src/dfa.c
index d1d7f25..7c0cf05 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -1725,7 +1725,7 @@ dfaanalyze (struct dfa *d, int searchflag)
   MALLOC(nalloc, int, d->tindex);
   for (i = 0; i < d->tindex; ++i)
     nalloc[i] = 0;
-  MALLOC(merged.elems, position, d->nleaves);
+  MALLOC(merged.elems, position, 2 * d->nleaves);
 
   CALLOC(d->follows, position_set, d->tindex);",1,1,First Developer Fix,N/A,,
grep.3c3bdace,OWMzNDk3N2,dfa.c:1917-1917,dfa.c:1452-1455,dfa.c:1728-1728,,,"In 3 region memory allocated for merged.elems, but in 2 block this memory did not enough and we get memory corruption.","diff --git a/src/dfa.c b/src/dfa.c
index d1d7f25..e750385 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -1725,7 +1725,7 @@ dfaanalyze (struct dfa *d, int searchflag)
   MALLOC(nalloc, int, d->tindex);
   for (i = 0; i < d->tindex; ++i)
     nalloc[i] = 0;
-  MALLOC(merged.elems, position, d->nleaves);
+  MALLOC(merged.elems, position, d->nleaves * 3);
 
   CALLOC(d->follows, position_set, d->tindex);
 
",1,1,First Developer Fix,N/A,,
grep.3c3bdace,NTM3Y2E1MW,src/dfa.c:1727-1729,src/dfa.c:1910-1917,src/dfa.c:2999-3000,,,"I think that there is some kind of a heap overflow happening here
MALLOC(merged.elems, position,   d->nleaves);

dfaanalyze() inserts more positions than the number of d->nleaves for expressions like the one given in the test
","--- dfa.c   2016-06-12 22:26:23.669001408 +0530
+++ dfa_copy.c  2016-06-12 22:27:05.221003390 +0530
@@ -1725,7 +1725,7 @@
   MALLOC(nalloc, int, d->tindex);
   for (i = 0; i < d->tindex; ++i)
     nalloc[i] = 0;
-  MALLOC(merged.elems, position, d->nleaves);
+  MALLOC(merged.elems, position,  2 * d->nleaves);

   CALLOC(d->follows, position_set, d->tindex);
",1,1,First Developer Fix,N/A,,
grep.3c3bdace,MjYyYzZkN2,src/dfa.c:1728,src/dfa.c:1453,src/dfa.c:1494,,,"The array allocated at region 1 was not large enough to endure all further manipulations (e.g. insert in region 2), so there was a heap corruption.","diff --git a/src/dfa.c b/src/dfa.c
index d1d7f25..c523d46 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -1725,7 +1725,7 @@ dfaanalyze (struct dfa *d, int searchflag)
   MALLOC(nalloc, int, d->tindex);
   for (i = 0; i < d->tindex; ++i)
     nalloc[i] = 0;
-  MALLOC(merged.elems, position, d->nleaves);
+  MALLOC(merged.elems, position, d->nleaves * 2);
 
   CALLOC(d->follows, position_set, d->tindex);
 
",1,1,First Developer Fix,N/A,,
grep.3c3bdace,ZmU3ZTExOW,src/dfa.c:1908,src/dfa.c:157,src/search.c:271,src/dfa.c:1624,,index was not passed properly. And wrong use of function at the place where it shouldn't be called.,"diff --git a/src/dfa.c b/src/dfa.c
index d1d7f25..cc617df 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -1883,7 +1883,6 @@ dfaanalyze (struct dfa *d, int searchflag)
        putc('\n', stderr);
 #endif
        copy(&d->follows[i], &merged);
-       epsclosure(&merged, d);
        if (d->follows[i].nelem < merged.nelem)
          REALLOC(d->follows[i].elems, position, merged.nelem);
        copy(&merged, &d->follows[i]);
@@ -1904,7 +1903,7 @@ dfaanalyze (struct dfa *d, int searchflag)

   /* Build the initial state. */
   d->salloc = 1;
-  d->sindex = 0;
+  d->sindex = 2;
   MALLOC(d->states, dfa_state, d->salloc);
   state_index(d, &merged, wants_newline, 0);
",1,0,Regression,Does not fix the problem of insufficient memory,,
grep.3c3bdace,MDUyYzIwMz,dfa.c:1460-1478,dfa.c:1436-1454,noother.c:0,,,the nelem field is wrong leading to oob,"diff --git a/src/dfa.c b/src/dfa.c
index d1d7f25..7d97f30 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -1433,26 +1433,23 @@ copy (position_set const *src, position_set *dst)
 static void
 insert (position p, position_set *s)
 {
-  int count = s->nelem;
-  int lo = 0, hi = count;
-  while (lo < hi)
-    {
-      int mid = ((unsigned) lo + (unsigned) hi) >> 1;
-      if (s->elems[mid].index < p.index)
-        lo = mid + 1;
-      else
-        hi = mid;
-    }
+  int i;
+  position t1, t2;
 
-  if (lo < count && p.index == s->elems[lo].index)
-    s->elems[lo].constraint |= p.constraint;
+  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)
+    continue;
+  if (i < s->nelem && p.index == s->elems[i].index)
+    s->elems[i].constraint |= p.constraint;
   else
     {
-      int i;
-      for (i = count; i > lo; i--)
-        s->elems[i] = s->elems[i - 1];
-      s->elems[lo] = p;
+      t1 = p;
       ++s->nelem;
+      while (i < s->nelem)
+        {
+          t2 = s->elems[i];
+          s->elems[i++] = t1;
+          t1 = t2;
+        }
     }
 }
 

",1,0,Regression,N/A,,
grep.3c3bdace,MGFkYmExOT,src/dfa.c:1453,src/dfa.c:1624,src/dfa.c:1886,src/dfa.c:1728,,"AddressSanitizer gave me the line in the insert() function src/dfa.c:1453 that causes the heap overflow, which, I suppose, leads to the bad free() and segfault later.
Comment on this insert() function states that s->elems must point to an array large enough to hold the resulting set. So, let's check the caller - epsclosure() at src/dfa.c:1624. Again the comment states that s->elems must be large enough. This function called from dfaanalyze() at src/dfa.c:1886, and that s->elems is actually ours merged.elems, which causes the segfault later.
It looks like merged.elems is malloc'ed once at the beginning of dfaanalyze() at src/dfa.c:1728.
I do not quite sure how it's size ends up being not enough for this particular case, but the easiest workaround would be just allocating some bigger buffer for merged.elems. I do not have enough time to dig into dfa code, so I decide to stick to this explanation/workaround.","diff --git a/src/dfa.c b/src/dfa.c
index d1d7f25..a1221fe 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -1725,7 +1725,7 @@ dfaanalyze (struct dfa *d, int searchflag)
   MALLOC(nalloc, int, d->tindex);
   for (i = 0; i < d->tindex; ++i)
     nalloc[i] = 0;
-  MALLOC(merged.elems, position, d->nleaves);
+  MALLOC(merged.elems, position, d->nleaves*2);
 
   CALLOC(d->follows, position_set, d->tindex);
 
",1,1,First Developer Fix,N/A,,
grep.54d55bba,OWUwOTY1N2,lib/savedir.c:51,lib/savedir.c:45-67,lib/savedir.c:45-67,,,"a typo in the variable. at lib/savedir:51 it was intended to remove trailing slashes from the directory name (variable dir), but variable path (possibly not allocated yet) was used instead.","diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..d9bb850 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,7 +48,7 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);
 
-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && dir[dirlen - 1] == '/')
     dirlen--;
 
   if ((dirlen + filelen + 2) > pathlen)
",1,1,Developer Fix,N/A,,
grep.54d55bba,YmI4MGM3ND,src/grep.c:1361,lib/savedir.c:123,lib/savedir.c:51,,,using wrong (uninitialized) variable (path instead of dir),"diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..d9bb850 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,7 +48,7 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);

-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && dir[dirlen - 1] == '/')
     dirlen--;

   if ((dirlen + filelen + 2) > pathlen)",1,1,Developer Fix,N/A,,
grep.54d55bba,MjYyZjkxNm,src/grep.c:1361-1361,lib/savedir.c:79-163,lib/savedir.c:48-66,,,We are accesing and indexing memory not initialized,"diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..d9bb850 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,7 +48,7 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);
 
-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && dir[dirlen - 1] == '/')
     dirlen--;
 
   if ((dirlen + filelen + 2) > pathlen)",1,1,Developer Fix,N/A,,
grep.54d55bba,ZGU4Yjc1ZG,lib/savedir.c:122-123,lib/savedir.c:51,src/grep.c:1361-1362,,,"For the given combination of arguments, function savedir() is called at src/grep.c:1361-1362. This function then call isdir1() at lib/savedir.c:122-123. There is a variable path global for savedir.c which is supposed to get a value in function isdir1(). However, variable path is used wrong at lib/savedir.c:51 before it has been initialized.","diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..849bad4 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,7 +48,7 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);
 
-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && dir[dirlen - 1] == '/') /* MEOLIC: BUG FIXING */
     dirlen--;
 
   if ((dirlen + filelen + 2) > pathlen)
",1,1,Developer Fix,N/A,,
grep.54d55bba,YmExODY3Yj,lib/savedir.c:47,lib/savedir.c:51,lib/savedir.c:47,,,null pointer deference,"diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..31c334a 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -47,7 +47,7 @@ isdir1 (const char *dir, const char *file)
 {
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);
-
+  if(!path) return 0;
   while (dirlen && path[dirlen - 1] == '/')
     dirlen--;

",1,0,Regression,isdir1 returns false even if dir is a directory,,
grep.54d55bba,ZWM2ODBmOG,grep/lib/savedir.c:51,grep/src/grep.c:1361,grep/lib/savedir.c:112,,,Program invokes savedir() function (grep/src/grep.c:1361). Function savedir() invokes isdir1() (grep/lib/savedir.c:112). Function isdir1() accessing NULL pointer at first time (grep/lib/savedir.c:51) causing segfault. ,"diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..d9bb850 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,7 +48,7 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);
 
-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && dir[dirlen - 1] == '/')
     dirlen--;
 
   if ((dirlen + filelen + 2) > pathlen)",1,1,Developer Fix,N/A,,
grep.54d55bba,OWMzNDk3N2,savedir.c:51-51,savedir.c:60-60,savedir.c:48-49,,,Wrong comparison in first region.,"diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..d9bb850 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,7 +48,7 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);
 
-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && dir[dirlen - 1] == '/')
     dirlen--;
 
   if ((dirlen + filelen + 2) > pathlen)
",1,1,Developer Fix,N/A,,
grep.54d55bba,ZjZhNTVkNj,grep/lib/savedir.c:51-52,grep/lib/savedir.c:51-52,grep/lib/savedir.c:51-52,,,"There were 3 errors:

1) Attempting to access the contents of an uninitialized string. In this case the path variable.

2) The == comparison operator needed to negated in second condition of the while loop

3) Braces needed to be placed around the dirlen-- decrement statement to complete the while statement.","diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..bdbd206 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,8 +48,10 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);
 
-  while (dirlen && path[dirlen - 1] == '/')
-    dirlen--;
+  while (dirlen && dir[dirlen - 1] != '/')
+    {
+      dirlen--; 
+    }
 
   if ((dirlen + filelen + 2) > pathlen)
     {
",1,0,Regression,isdir1 removes directory name until slash is reached,,
grep.54d55bba,NTM3Y2E1MW,src/grep.c:1360-1362,lib/savedir.c:122-124,lib/savedir.c:50-52,,,path[dirlen - 1] == '/' . This is leading to the segmentation fault. Since path is not pointing to any valid memory location yet when this call is made.,"--- savedir.c   2016-06-12 19:52:44.940561625 +0530
+++ savedir_copy.c  2016-06-12 19:58:06.780576978 +0530
@@ -48,7 +48,7 @@
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);

-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && dir[dirlen - 1] == '/')
     dirlen--;

   if ((dirlen + filelen + 2) > pathlen)
",1,1,Developer Fix,N/A,,
grep.54d55bba,MDliMzQ4OT,lib/savedir.c:51,lib/savedir.c:122,src/grep.c:1361,,,The cause of error was using global pointer variable before its initialization.,"diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..f66142f 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,7 +48,7 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);
 
-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && path && path[dirlen - 1] == '/')
     dirlen--;
 
   if ((dirlen + filelen + 2) > pathlen)
",1,0,Regression,"Effectively, does not remove trailing slashes anymore",,
grep.54d55bba,ZmU3ZTExOW,src/grep.c:1291,src/grep.c:1105,src/grep.c:1361,lib/savedir.c:123,lib/savedir.c:51,different path name given mistakenly which was not even defined yet. ,"diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..d9bb850 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,7 +48,7 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);

-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && dir[dirlen - 1] == '/')
     dirlen--;

   if ((dirlen + filelen + 2) > pathlen)",1,1,Developer Fix,N/A,,
grep.54d55bba,MDUyYzIwMz,savedir.c:51,grep.c:1361,noother.c:0,,,Unchecked Null pointer,"diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..f66142f 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,7 +48,7 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);
 
-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && path && path[dirlen - 1] == '/')
     dirlen--;
 
   if ((dirlen + filelen + 2) > pathlen)

",1,0,Regression,"Effectively, does not remove trailing slashes anymore",,
grep.54d55bba,MGFkYmExOT,lib/savedir.c:51,none.c:0,none.c:0,,,Just a typo.,"diff --git a/lib/savedir.c b/lib/savedir.c
index 45bf9c3..d9bb850 100644
--- a/lib/savedir.c
+++ b/lib/savedir.c
@@ -48,7 +48,7 @@ isdir1 (const char *dir, const char *file)
   size_t dirlen = strlen (dir);
   size_t filelen = strlen (file);
 
-  while (dirlen && path[dirlen - 1] == '/')
+  while (dirlen && dir[dirlen - 1] == '/')
     dirlen--;
 
   if ((dirlen + filelen + 2) > pathlen)
",1,1,Developer Fix,N/A,,
grep.55cf7b6a,OWUwOTY1N2,src/main.c:1217-1223,src/main.c:1246-1255,src/main.c:1852-1859,,,stdin file is skipped on --device=skip option.,"diff --git a/src/main.c b/src/main.c
index 3376fa4..eadedc9 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1249,9 +1249,10 @@ grepfile (char const *file, struct stats *stats)
                                       || S_ISSOCK (stats->stat.st_mode)
                                       || S_ISFIFO (stats->stat.st_mode))))
     {
-      if (file)
+      if (file) {
         close (desc);
-      return 1;
+        return 1;
+      }
     }
 
   /* If there is a regular file on stdout and the current file refers
",1,1,Different but Correct,N/A,,
grep.55cf7b6a,YmI4MGM3ND,src/main.c:1853,src/main.c:2238,src/main.c:1247,,,"code at the main.c:1247 doesn't take into account that ""skip"" action shouldn't be applied in case of ""input from STDIN""","diff --git a/src/main.c b/src/main.c
index 3376fa4..aba1c34 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1243,8 +1243,9 @@ grepfile (char const *file, struct stats *stats)
       return 1;
     }

+
   if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
-      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
+      || (desc != STDIN_FILENO && devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
                                       || S_ISBLK (stats->stat.st_mode)
                                       || S_ISSOCK (stats->stat.st_mode)
                                       || S_ISFIFO (stats->stat.st_mode))))
",1,1,Developer Fix,N/A,,
grep.55cf7b6a,MjYyZjkxNm,src/main.c:403-408,src/main.c:1853-1860,src/main.c:1211-1285,,,"Skip rule for -D option is applied in section 3 to stdout, when the option information says that: ""This option has no effect on a file that is read via standard input"". It should not be applied and input must be processed","--- a/src/main.c
+++ b/src/main.c
@@ -1243,16 +1243,17 @@ grepfile (char const *file, struct stats *stats)
       return 1;
     }
 
-  if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
-      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
-                                      || S_ISBLK (stats->stat.st_mode)
-                                      || S_ISSOCK (stats->stat.st_mode)
-                                      || S_ISFIFO (stats->stat.st_mode))))
-    {
-      if (file)
-        close (desc);
-      return 1;
-    }
+  if (desc != STDIN_FILENO)
+    if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
+        || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
+                                        || S_ISBLK (stats->stat.st_mode)
+                                        || S_ISSOCK (stats->stat.st_mode)
+                                        || S_ISFIFO (stats->stat.st_mode))))
+      {
+        if (file)
+          close (desc);
+        return 1;
+      }",1,1,Developer Fix,N/A,,
grep.55cf7b6a,ZGU4Yjc1ZG,src/main.c:1854-1861,src/main.c:1246-1251,src/main.c:1256,,,"For -D the program sets variable devices = SKIP_DEVICES at src/main.c:1854-1861. Before any input is being evaluated, it is checked, if this input should be skipped, see src/main.c:1246-1251. I do not understand all constants used in the if statement at src/main.c:1246-1251 but they somehow include stdin and this is wrong. As the result, return 1 at src/main.c:1256 is being executed for stdin.","diff --git a/src/main.c b/src/main.c
index 3376fa4..ed3a413 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1244,7 +1244,9 @@ grepfile (char const *file, struct stats *stats)
     }
 
   if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
-      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
+      || (devices == SKIP_DEVICES &&
+             desc != STDIN_FILENO && /* MEOLIC: BUG FIXING */
+                                     (S_ISCHR (stats->stat.st_mode)
                                       || S_ISBLK (stats->stat.st_mode)
                                       || S_ISSOCK (stats->stat.st_mode)
                                       || S_ISFIFO (stats->stat.st_mode))))
",1,1,Developer Fix,N/A,,
grep.55cf7b6a,ZWM2ODBmOG,grep/src/main.c:1217-1218,grep/src/main.c:1246-1255,grep/src/main.c:1209-1346,,,"Program checks and open device for input (grep/src/main.c:1209-1346). If device is stdin, no need to open it due fd of stdin is passed on program start already (grep/src/main.c:1217-1218). Due stdin have S_IFIFO type, SKIP_DEVICE option causing program exit on file stat check (grep/src/main.c:1246-1255). ","diff --git a/src/main.c b/src/main.c
index 3376fa4..5c26997 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1243,11 +1243,11 @@ grepfile (char const *file, struct stats *stats)
       return 1;
     }
 
-  if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
+  if (file && ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
       || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
                                       || S_ISBLK (stats->stat.st_mode)
                                       || S_ISSOCK (stats->stat.st_mode)
-                                      || S_ISFIFO (stats->stat.st_mode))))
+                                      || S_ISFIFO (stats->stat.st_mode)))))
     {
       if (file)
         close (desc);",1,1,Different but Correct,N/A,,
grep.55cf7b6a,OWMzNDk3N2,main.c:1852-1859,main.c:1217-1223,main.c:1246-1255,,,"SKIP_DEVICES set in first range, and in 3 range we check up for device state, and miss checking for STDIN_FILENO.","diff --git a/src/main.c b/src/main.c
index 3376fa4..c5b8855 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1244,12 +1244,12 @@ grepfile (char const *file, struct stats *stats)
     }
 
   if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
-      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
+      || (devices == SKIP_DEVICES && desc != STDIN_FILENO
+                                                                                  && (S_ISCHR (stats->stat.st_mode)
                                       || S_ISBLK (stats->stat.st_mode)
                                       || S_ISSOCK (stats->stat.st_mode)
                                       || S_ISFIFO (stats->stat.st_mode))))
     {
-      if (file)
         close (desc);
       return 1;
     }
",1,1,Developer Fix,N/A,,
grep.55cf7b6a,NTM3Y2E1MW,src/main.c:1851-1857,src/main.c:1214-1218,src/main.c:1246-1255,,,"SInce we had used -D skip option, the stdin was getting skipped. Ideally, this should not happen for stdin. I added a check to make sure that this doesnt happen

To quote from the MAN page 
""If an input file is a device, FIFO, or socket, use action to process it. If action is ‘read’, all devices are read just as if they were ordinary files. If action is ‘skip’, devices, FIFOs, and sockets are silently skipped. By default, devices are read if they are on the command line or if the -R (--dereference-recursive) option is used, and are skipped if they are encountered recursively and the -r (--recursive) option is used. This option has no effect on a file that is read via standard input.""

This option has no effect on a file that is read via standard input.
the above was missing","--- main.c  2016-06-13 16:48:29.862278919 +0530
+++ main_copy.c 2016-06-13 16:49:36.546282100 +0530
@@ -1243,11 +1243,11 @@
       return 1;
     }

-  if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
+  if ( (desc != STDIN_FILENO) && ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
       || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
                                       || S_ISBLK (stats->stat.st_mode)
                                       || S_ISSOCK (stats->stat.st_mode)
-                                      || S_ISFIFO (stats->stat.st_mode))))
+                                      || S_ISFIFO (stats->stat.st_mode)))))
     {
       if (file)
         close (desc);
",1,1,Developer Fix,N/A,,
grep.55cf7b6a,MDliMzQ4OT,src/main.c:1217,src/main.c:1247,src/main.c:1792,,,There were no checking of file descriptor being stdin when checking for device to skip in region 1.,"diff --git a/src/main.c b/src/main.c
index 3376fa4..2d7fca5 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1244,7 +1244,7 @@ grepfile (char const *file, struct stats *stats)
     }
 
   if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
-      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
+      || (desc && devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
                                       || S_ISBLK (stats->stat.st_mode)
                                       || S_ISSOCK (stats->stat.st_mode)
                                       || S_ISFIFO (stats->stat.st_mode))))
",1,1,Developer Fix,N/A,,
grep.55cf7b6a,ZmU3ZTExOW,grep/main.c:1247,grep/main.c:1254,grep/main.c:1219,,,in wrong case it waas going intto if condition. Actully if we write -D skip then should skip the part instead of exiting program.,"diff --git a/src/main.c b/src/main.c
index 3376fa4..3d2c35e 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1243,8 +1243,8 @@ grepfile (char const *file, struct stats *stats)
       return 1;
     }

-  if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
-      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
+  if (!(directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
+      || !(devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
                                       || S_ISBLK (stats->stat.st_mode)
                                       || S_ISSOCK (stats->stat.st_mode)
                                       || S_ISFIFO (stats->stat.st_mode))))
",1,0,Regression,Skip everything that should not be skipped (while not skipping STDIN),,
grep.55cf7b6a,MGFkYmExOT,main.c:1246,main.c:1218,none.c:0,,,desc is STDIN_FILENO at main.c:1218. So if statement is taken on main.c:1246 because stdin is a character device indeed (S_ISCHR (stats->stat.st_mode)).,"diff --git a/src/main.c b/src/main.c
index 3376fa4..1ee0448 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1244,10 +1244,12 @@ grepfile (char const *file, struct stats *stats)
     }
 
   if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
-      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
-                                      || S_ISBLK (stats->stat.st_mode)
-                                      || S_ISSOCK (stats->stat.st_mode)
-                                      || S_ISFIFO (stats->stat.st_mode))))
+      || (devices == SKIP_DEVICES
+          && desc != STDIN_FILENO
+          && (S_ISCHR (stats->stat.st_mode)
+              || S_ISBLK (stats->stat.st_mode)
+              || S_ISSOCK (stats->stat.st_mode)
+              || S_ISFIFO (stats->stat.st_mode))))
     {
       if (file)
         close (desc);
",1,1,Developer Fix,N/A,,
grep.55cf7b6a,MDUyYzIwMz,main.c:1251,main.c:1217-1220,main.c:1856,,,"stdin is a special device, we still dont want to skip it if -D skip is specified","diff --git a/src/main.c b/src/main.c
index 3376fa4..b5bf5ea 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1244,7 +1244,7 @@ grepfile (char const *file, struct stats *stats)
     }
 
   if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
-      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
+      || (devices == SKIP_DEVICES && desc != STDIN_FILENO && (S_ISCHR (stats->stat.st_mode)
                                       || S_ISBLK (stats->stat.st_mode)
                                       || S_ISSOCK (stats->stat.st_mode)
                                       || S_ISFIFO (stats->stat.st_mode))))
",1,1,Developer Fix,N/A,,
grep.58195fab,OWUwOTY1N2,src/grep.c:2139,src/grep.c:2264-2273,lib/exclude.c:417-427,lib/exclude.c:445-487,,"Basically, the ability to specify filename glob patterns for --include option was not turned on.","diff --git a/src/grep.c b/src/grep.c
index fbeb089..b86e3de 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
         if (!included_patterns)
           included_patterns = new_exclude ();
-        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE | EXCLUDE_WILDCARDS);
         break;
 
 
",1,1,Different but Correct,N/A,,
grep.58195fab,YmI4MGM3ND,src/grep.c:2135,src/grep.c:2115,src/grep.c:2258-2285,lib/exclude.c:398-440,lib/exclude.c:445-487,"1. included_patterns initialized without ""EXCLUDE_WILDCARDS"" flag - getting matched in wrong way (src/grep.c:2135)
2. loop in ""main"" function src/grep.c:2258-2285 handling ""excludes"" and ""includes"" in wrong way. especially, when checking ""excluded_file_name"" there's no need to invert result as it handled internally with EXCLUDE_INCLUDE flag","diff --git a/src/grep.c b/src/grep.c
index fbeb089..46195c6 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
        if (!included_patterns)
          included_patterns = new_exclude ();
-       add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+       add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE | EXCLUDE_WILDCARDS);
        break;


@@ -2264,14 +2264,15 @@ There is NO WARRANTY, to the extent permitted by law.\n""),
          if ((included_patterns || excluded_patterns)
              && !isdir (file))
            {
+                 if (excluded_patterns &&
+                                 excluded_file_name (excluded_patterns, file))
+                               continue;
              if (included_patterns &&
-                 ! excluded_file_name (included_patterns, file))
-               continue;
-             if (excluded_patterns &&
-                 excluded_file_name (excluded_patterns, file))
-               continue;
+                   excluded_file_name (included_patterns, file))
+                 status &= grepfile (file, &stats_base);
            }
-         status &= grepfile (strcmp (file, ""-"") == 0 ? (char *) NULL : file,
+         else
+                 status &= grepfile (strcmp (file, ""-"") == 0 ? (char *) NULL : file,
                              &stats_base);
        }
        while ( ++optind < argc);
",1,1,Different but Correct,N/A,,
grep.58195fab,MjYyZjkxNm,src/grep.c:2136-2140,src/grep.c:2136-2140,lib/exclude.c:399-440,,,"Not added support to wildcards correctly at --include option at section 1,","--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
        if (!included_patterns)
          included_patterns = new_exclude ();
-       add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+       add_exclude (included_patterns, optarg, EXCLUDE_WILDCARDS | EXCLUDE_INCLUDE);
        break;",1,1,Different but Correct,N/A,,
grep.58195fab,ZGU4Yjc1ZG,src/grep.c:2136-2140,src/grep.c:2267-2269,src/grep.c:2274,,,"For --include, the program call add_exclude() with wrong arguments, see src/grep.c:2136-2140. In the original program, wildcard patterns were simply ignored and files get added with wrong options (i.e it will be recognized in the way as if they are in --exclude). Because of wrong information stored in variable included_patterns, files are not correctly classified at src/grep.c:2267-2269. Thus, wrong files go for evaluation in src/grep.c:2274.","diff --git a/src/grep.c b/src/grep.c
index fbeb089..b571a61 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
         if (!included_patterns)
           included_patterns = new_exclude ();
-        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+        add_exclude (included_patterns, optarg, EXCLUDE_WILDCARDS); /* MEOLIC: BUG FIXING */
         break;
 
 
",1,0,Regression,EXCLUDE_INCLUDE flags must also be set for includes,,
grep.58195fab,ZWM2ODBmOG,grep/src/grep.c:2267-2269,grep/lib/exclude.c:417-431,grep/lib/exclude.c:449-450,grep/src/grep.c:2139,,"Program tests input file name on include/exclude list match (grep/src/grep.c:2267-2269).  Depended on command line option, file matched to a exact name or to a wildcard pattern (grep/lib/exclude.c:417-431). Wildcard pattern rule is added only when EXCLUDE_WILDCARDS option passed to add_exclude() function. But add_exclude function invoked on command line parsing have no such option passed (grep/src/grep.c:2139). ","diff --git a/src/grep.c b/src/grep.c
index fbeb089..b86e3de 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
         if (!included_patterns)
           included_patterns = new_exclude ();
-        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE | EXCLUDE_WILDCARDS);
         break;",1,1,Different but Correct,N/A,,
grep.58195fab,OWMzNDk3N2,grep.c:2136-2139,lib/exclude.c:450-451,grep.c:2115-2118,,,"Missed argument in range #1, must be like in range #3:

add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE | EXCLUDE_WILDCARDS);
instead of
add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);","diff --git a/gnulib b/gnulib
--- a/gnulib
+++ b/gnulib
@@ -1 +1 @@
-Subproject commit c5588be343f580be8e87d99e043dcdf3d7606759
+Subproject commit c5588be343f580be8e87d99e043dcdf3d7606759-dirty
diff --git a/src/grep.c b/src/grep.c
index fbeb089..b86e3de 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
         if (!included_patterns)
           included_patterns = new_exclude ();
-        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE | EXCLUDE_WILDCARDS);
         break;
 
 
",1,1,Different but Correct,N/A,,
grep.58195fab,NTM3Y2E1MW,src/grep.c:2129-2141,lib/exclude.c:444-487,lib/exclude.c:114-135,,,The option EXCLUDE_WILDCARDS was missing in the included option and hence this was including all the files other than those with .e ,"--- grep.c  2016-06-13 14:10:04.444006255 +0530
+++ grep_copy.c 2016-06-13 14:10:58.476008833 +0530
@@ -2136,7 +2136,7 @@
       case INCLUDE_OPTION:
    if (!included_patterns)
      included_patterns = new_exclude ();
-   add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+   add_exclude (included_patterns, optarg, EXCLUDE_WILDCARDS | EXCLUDE_INCLUDE);
    break;
",1,1,Different but Correct,N/A,,
grep.58195fab,ZmU3ZTExOW,src/grep.c:2267,lib/exclude.c:457,lib/exclude.c:465,,,* pattern is not getting recognised by program. So wildcard entries are not working.,"diff --git a/gnulib b/gnulib
--- a/gnulib
+++ b/gnulib
@@ -1 +1 @@
-Subproject commit c5588be343f580be8e87d99e043dcdf3d7606759
+Subproject commit c5588be343f580be8e87d99e043dcdf3d7606759-dirty
diff --git a/src/grep.c b/src/grep.c
index fbeb089..922f675 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2265,7 +2265,7 @@ There is NO WARRANTY, to the extent permitted by law.\n""),
              && !isdir (file))
            {
              if (included_patterns &&
-                 ! excluded_file_name (included_patterns, file))
+                  excluded_file_name (included_patterns, file))
                continue;
              if (excluded_patterns &&
                  excluded_file_name (excluded_patterns, file))
",0,0,Regression,"If file is specified to be excluded, then include it.",,
grep.58195fab,MjYyYzZkN2,src/grep.c:2139,src/grep.c:2268,gnulib/lib/exclude.c:419,,,"When filling include pattern structure from command line (region 1), it was missing type flag EXCLUDE_WILDCARDS, so then, when choosing to exclude/include file in search (region 2) and calling corresponding function, the pattern was interpreted incorrectly (region 3 - it went on second switch case, even though it should've go first). So plain file include pattern worked alright, but the regex one (including asterisks etc) was screwed.","diff --git a/src/grep.c b/src/grep.c
index fbeb089..b86e3de 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
         if (!included_patterns)
           included_patterns = new_exclude ();
-        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE | EXCLUDE_WILDCARDS);
         break;
",1,1,Different but Correct,N/A,,
grep.58195fab,MGFkYmExOT,grep.c:2139,exclude.c:449,grep.c:2118,,,"Forgotten EXCLUDE_WILDCARDS at grep.c:2139. After calling add_exclude exclude.c:449 without EXCLUDE_WILDCARDS it treats ""*.e"" as a filename, not as a pattern. So it behaves like --include is omitted.","diff --git a/src/grep.c b/src/grep.c
index fbeb089..b86e3de 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
        if (!included_patterns)
          included_patterns = new_exclude ();
-       add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+       add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE | EXCLUDE_WILDCARDS);
        break;
 
 
",1,1,Different but Correct,N/A,,
grep.58195fab,MDUyYzIwMz,grep.c:2137-2139,grep.c:2268,noother.c:0,,,the include pattern is basically the same as the exclude pattern. except that we negate the return value of excluded_file_name. however at grep.c:2139 we say that the include patterns are actually include patterns. but then wildcards are not supported ,"diff --git a/src/grep.c b/src/grep.c
index fbeb089..05df4dc 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
         if (!included_patterns)
           included_patterns = new_exclude ();
-        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE | EXCLUDE_WILDCARDS);
         break;
 
 

",1,1,Different but Correct,N/A,,
grep.5fa8c7c9,OWUwOTY1N2,src/kwsearch.c:103-122,src/searchutils.c:117-145,src/main.c:1019,src/main.c:998,,"empty match is a degenerate case when `is_mb_middle` always returns true, which was not accounted in Fexecute function.","diff --git a/src/kwsearch.c b/src/kwsearch.c
index 973eb60..33e19d8 100644
--- a/src/kwsearch.c
+++ b/src/kwsearch.c
@@ -105,7 +105,7 @@ Fexecute (char const *buf, size_t size, size_t *match_size,
         goto failure;
       len = kwsmatch.size[0];
 #ifdef MBS_SUPPORT
-      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size,
+      if (len && MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size,
                                           len))
         {
           /* The match was a part of multibyte character, advance at least
",1,1,Different but Correct,N/A,,
grep.5fa8c7c9,YmI4MGM3ND,src/kwsearch.c:80,src/kwsearch.c:101,src/kwsearch.c:108,src/searchutils.c:117,,"src/kwsearch.c:101 loop never ends because  variable used in ""loop finish"" condition get re-initialized in case ""no match"";","diff --git a/src/kwsearch.c b/src/kwsearch.c
index 973eb60..e574fd4 100644
--- a/src/kwsearch.c
+++ b/src/kwsearch.c
@@ -105,7 +105,7 @@ Fexecute (char const *buf, size_t size, size_t *match_size,
        goto failure;
       len = kwsmatch.size[0];
 #ifdef MBS_SUPPORT
-      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size,
+      if (MB_CUR_MAX > 1 && len && is_mb_middle (&mb_start, beg + offset, buf + size,
                                          len))
         {
           /* The match was a part of multibyte character, advance at least
",1,1,Different but Correct,N/A,,
grep.5fa8c7c9,MjYyZjkxNm,src/main.c:1010-1057,src/kwsearch.c:136-152,src/kwsearch.c:101-122,,,Infinite loop at logic of FExecute function within section 3,"diff --git a/src/kwsearch.c b/src/kwsearch.c
index 973eb60..9cdae03 100644
--- a/src/kwsearch.c
+++ b/src/kwsearch.c
@@ -103,6 +103,11 @@ Fexecute (char const *buf, size_t size, size_t *match_size,
       size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
       if (offset == (size_t) -1)
        goto failure;
+      if (offset == 0)
+      {
+        len = size;
+        goto success;
+      }
       len = kwsmatch.size[0];
 #ifdef MBS_SUPPORT
       if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size,",1,0,Regression,breaks normal matches at the beginning. Should not return complete buffer,,
grep.5fa8c7c9,ZGU4Yjc1ZG,src/kwsearch.c:101-155,src/kwsearch.c:106,src/kwsearch.c:108,src/searchutils.c:116-146,src/kwsearch.c:113-121,"For -F, loop at src/kwsearch.c:101-155 is being executed. First, a call to kwsexec() is used to check for matching. If there is a match, variable len gets the size of the match, see src/kwsearch.c:106. Then, if using UTF-8 mode, a specific test is made to check whether the match is a part of multibyte character, see  src/kwsearch.c:108. This test includes a call to is_mb_middle() implemented at src/searchutils.c:116-146. In the case of len=0 (which happens when matching with """" which by definition matches anything) this function returns true but actions performed at src/kwsearch.c:113-121 are wrong for len = 0,","diff --git a/src/kwsearch.c b/src/kwsearch.c
index 973eb60..7a523a1 100644
--- a/src/kwsearch.c
+++ b/src/kwsearch.c
@@ -105,7 +105,7 @@ Fexecute (char const *buf, size_t size, size_t *match_size,
         goto failure;
       len = kwsmatch.size[0];
 #ifdef MBS_SUPPORT
-      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size,
+      if (MB_CUR_MAX > 1 && len && is_mb_middle (&mb_start, beg + offset, buf + size, /* MEOLIC: BUG FIXING */
                                           len))
         {
           /* The match was a part of multibyte character, advance at least
",1,1,Different but Correct,N/A,,
grep.5fa8c7c9,ZWM2ODBmOG,grep/src/kwsearch.c:101-121,grep/src/searchutils.c:145,grep/src/kwsearch.c:108,,,Program goes to infinite loop (grep/src/kwsearch.c:101-121) due is_mb_middle() function invoked (grep/src/kwsearch.c:108) always returns 'true' for 0 length value (grep/src/searchutils.c:145). So program decides that it is in middle of multibyte character but can not advance due there are no bytes character at all.,"diff --git a/src/searchutils.c b/src/searchutils.c
index 8c34e31..fdad165 100644
--- a/src/searchutils.c
+++ b/src/searchutils.c
@@ -121,6 +121,9 @@ is_mb_middle (const char **good, const char *buf, const char *end,
   const char *prev = p;
   mbstate_t cur_state;
 
+  if (0 >= match_len)
+    return false;
+
   /* TODO: can be optimized for UTF-8.  */
   memset(&cur_state, 0, sizeof(mbstate_t));
   while (p < buf)",1,1,Developer Fix,N/A,,
grep.5fa8c7c9,OWMzNDk3N2,kwsearch.c:101-155,kwsearch.c:118-118,kwsearch.c:101-101,,,Wrong instruction,"diff --git a/src/kwsearch.c b/src/kwsearch.c
index 973eb60..68dfe08 100644
--- a/src/kwsearch.c
+++ b/src/kwsearch.c
@@ -115,7 +115,6 @@ Fexecute (char const *buf, size_t size, size_t *match_size,
           size_t mb_len = mbrlen (mb_start, (buf + size) - (beg + offset), &s);
           if (mb_len == (size_t) -2)
             goto failure;
-          beg = mb_start;
           if (mb_len != (size_t) -1)
             beg += mb_len - 1;
           continue;
",1,0,Treating the symptom,breaks multibyte character handling,,
grep.5fa8c7c9,ZjZhNTVkNj,grep/src/kwsearch.c:121,grep/src/kwsearch.c:121,grep/src/kwsearch.c:121,,,An erroneous continue statement circumvented the intended execution path.,"diff --git a/src/kwsearch.c b/src/kwsearch.c
index 973eb60..e1e5e66 100644
--- a/src/kwsearch.c
+++ b/src/kwsearch.c
@@ -118,7 +118,6 @@ Fexecute (char const *buf, size_t size, size_t *match_size,
           beg = mb_start;
           if (mb_len != (size_t) -1)
             beg += mb_len - 1;
-          continue;
         }
 #endif /* MBS_SUPPORT */
       beg += offset;",1,0,Treating the symptom,breaks multibyte character handling,,
grep.5fa8c7c9,NTM3Y2E1MW,src/main.c:1019-1020,src/main.c:982-984,src/kwsearch.c:100-155,src/searchutils.c:116-146,,"Well, to be honest , I did not quite understand everything about the bug
is_mb_middle was returning true for when it wasn't supposed in turn making the for loop to become infinite","--- searchutils.c   2016-06-13 02:16:05.325350514 +0530
+++ searchutils_copy.c  2016-06-13 02:17:42.393355145 +0530
@@ -142,6 +142,6 @@
     }

   *good = prev;
-  return p > buf || match_len < mbrlen (p, end - p, &cur_state);
+  return p > buf;
 }
 #endif /* MBS_SUPPORT */",1,0,Treating the symptom,breaks multibyte character handling,,
grep.5fa8c7c9,MDliMzQ4OT,src/kwsearch.c:120,src/kwsearch.c:116,src/main.c:984,,,There were no checking for search string being empty in case of multibyte characters (region 1).,"diff --git a/src/kwsearch.c b/src/kwsearch.c
index 973eb60..2c239af 100644
--- a/src/kwsearch.c
+++ b/src/kwsearch.c
@@ -118,6 +118,8 @@ Fexecute (char const *buf, size_t size, size_t *match_size,
           beg = mb_start;
           if (mb_len != (size_t) -1)
             beg += mb_len - 1;
+          if (mb_len == 1)
+            goto success;
           continue;
         }
 #endif /* MBS_SUPPORT */
",1,1,Different but Correct,workaround that works only in this degenerate case,,
grep.5fa8c7c9,ZmU3ZTExOW,find/kwsearch.c:33,find/kwsearch.c:73,find/kwsearch.c:166,find/kwsearch.c:101,,only one case was taken care of. multibyte character may be size of -1 or 0 or <0 and so on but condition was only for -2. so it was going in loop if we dont handle other sizes. ,"diff --git a/src/kwsearch.c b/src/kwsearch.c
index 973eb60..83b41c8 100644
--- a/src/kwsearch.c
+++ b/src/kwsearch.c
@@ -113,7 +113,7 @@ Fexecute (char const *buf, size_t size, size_t *match_size,
           mbstate_t s;
           memset (&s, 0, sizeof s);
           size_t mb_len = mbrlen (mb_start, (buf + size) - (beg + offset), &s);
-          if (mb_len == (size_t) -2)
+          if (mb_len <= (size_t) -2)
             goto failure;
           beg = mb_start;
           if (mb_len != (size_t) -1)
",1,0,Regression,Always fail to match multibyte characters,,
grep.5fa8c7c9,MDUyYzIwMz,kwsearch.c:115,noother.c:0,noother.c:0,,,Infinite loop due to resetting beg to mb_start,"diff --git a/src/kwsearch.c b/src/kwsearch.c
index 973eb60..4b14c04 100644
--- a/src/kwsearch.c
+++ b/src/kwsearch.c
@@ -112,10 +112,9 @@ Fexecute (char const *buf, size_t size, size_t *match_size,
              one byte to ensure no infinite loop happens.  */
           mbstate_t s;
           memset (&s, 0, sizeof s);
-          size_t mb_len = mbrlen (mb_start, (buf + size) - (beg + offset), &s);
+          size_t mb_len = mbrlen (beg + offset, (buf + size) - (beg + offset), &s);
           if (mb_len == (size_t) -2)
             goto failure;
-          beg = mb_start;
           if (mb_len != (size_t) -1)
             beg += mb_len - 1;
           continue;

",1,0,Treating the symptom,breaks multibyte character handling,,
grep.5fa8c7c9,MGFkYmExOT,kwsearch.c:108,kwsearch.c:120,kwsearch.c:101,,,"is_mb_middle() returns true at src/kwsearch.c:108, but we are not in the middle of the multibyte char, so it ends up at the start of the string at kwsearch.c:120.","diff --git a/src/searchutils.c b/src/searchutils.c
index 8c34e31..c9ad373 100644
--- a/src/searchutils.c
+++ b/src/searchutils.c
@@ -142,6 +142,6 @@ is_mb_middle (const char **good, const char *buf, const char *end,
     }
 
   *good = prev;
-  return p > buf || match_len < mbrlen (p, end - p, &cur_state);
+  return p > buf || (match_len > 0 && match_len < mbrlen (p, end - p, &cur_state));
 }
 #endif /* MBS_SUPPORT */
",1,1,Developer Fix,N/A,,
grep.7aa698d3 ,OWUwOTY1N2,src/grep.c:1060-1062,src/search.c:382-396,src/search.c:388,,,"I with dot' lowered takes 1 less byte, and grep is anaware of such possibility, so it miscalculates the match length for unlowered string.","diff --git a/src/grep.c b/src/grep.c
index 2dc3ee9..5cb5ef1 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1059,7 +1059,11 @@ static EXECUTE_RET do_execute EXECUTE_ARGS
 
       result = execute (line_buf, line_next - line_buf, match_size, start_ptr);
       if (result != (size_t) -1)
-       return (line_buf - buf) + result;
+        {
+          if (match_size)
+            *match_size = line_next - line_buf;
+          return (line_buf - buf) + result;
+        }
     }
 
   return (size_t) -1;
",1,0,Regression,Only match should be printed,,
grep.7aa698d3 ,MjYyZjkxNm,src/grep.c:964-1026,src/grep.c:1074-1091,src/grep.c:893-934,,,"Wrong use of lim variable at section 2, when converting to lower case we half its value, but we must continue using the original one for printing","diff --git a/src/grep.c b/src/grep.c
index 2dc3ee9..ee1c213 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1088,7 +1088,7 @@ grepbuf (char const *beg, char const *lim)
        break;
       if (!out_invert)
        {
-         prtext (b, endp, (int *) 0);
+         prtext (b, lim, (int *) 0);
          nlines++;
           outleft--;
          if (!outleft || done_on_match)",1,0,Regression,Only match should be printed,,
grep.7aa698d3 ,YmI4MGM3ND,src/grep.c:1071-1119,src/grep.c:1028-1065,src/search.c:385-401,,,"""do_execute"" actual implementation (src/search.c:385-401) returns  match_size (length of matched string in bytes) calclated by lowercased string and it's length in bytes is twice less than original string (because lowecased string using single byte per character)","diff --git a/src/search.c b/src/search.c
index 1c9272e..64632d4 100644
--- a/src/search.c
+++ b/src/search.c
@@ -377,6 +377,9 @@ EXECUTE_FCT(EGexecute)
   int backref, start, len, best_len;
   struct kwsmatch kwsm;
   size_t i, ret_val;
+  size_t orig_size = size;
+  int is_wc_upper_case = 0;
+
 #ifdef MBS_SUPPORT
   char *mb_properties = NULL;
   if (MB_CUR_MAX > 1)
@@ -386,6 +389,8 @@ EXECUTE_FCT(EGexecute)
           /* mbtolower adds a NUL byte at the end.  That will provide
             space for the sentinel byte dfaexec may add.  */
           char *case_buf = mbtolower (buf, &size);
+          if (size < orig_size)
+                 is_wc_upper_case = 1;
          if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
           buf = case_buf;
@@ -556,8 +561,10 @@ EXECUTE_FCT(EGexecute)
  success_in_len:
   *match_size = len;
   ret_val = beg - buf;
- out:
+  out:
 #ifdef MBS_SUPPORT
+  if (is_wc_upper_case)
+         *match_size = (len - 1) * 2 + 1;
   if (MB_CUR_MAX > 1)
     free (mb_properties);
 #endif /* MBS_SUPPORT */
",1,0,Regression,Works only for the test case. Not always exactly half.,,
grep.7aa698d3 ,ZGU4Yjc1ZG,src/grep.c:1081-1085,src/search.c:388,src/grep.c:1091,,,"Function do_execute() check buffer for a match and returns the size of the match, see src/grep.c:1081-1085. This information (variable match_size) is then used to print out the matched line and also to guide following searches (there could be more than one line in the buffer at once). But for UTF-8, if -i is used then during the search for a match then current line is transformed to lowercase letters, see src/search.c:388 and for some characters the length in bytes differ from the original. In such cases, variable match_size will contain number of bytes in the transformed line, not in the original line and prtext at src/grep.c:1091 will print out wrong text. Regarding the root cause, the situation was already explained in the bug description but the solution is not obvious. During the transformation to lowercase letters no info about mapping is recorded and, indeed, it could not be recovered by simply reverse action (i.e. change to uppercase).","diff --git a/src/grep.c b/src/grep.c
index 2dc3ee9..9735722 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1083,6 +1083,34 @@ grepbuf (char const *beg, char const *lim)
     {
       char const *b = p + match_offset;
       char const *endp = b + match_size;
+
+      /* MEOLIC: BUG FIXING */
+#ifdef MBS_SUPPORT
+      if (MB_CUR_MAX > 1)
+      {
+        if (match_icase) {
+          /* check a mapping between the original and the converted letters */
+          /* adjust endp if necessary */
+          char *p1 = p;
+          char p2[MB_CUR_MAX];
+          size_t length1,length2,length3;
+          wchar_t onechar;
+          mbstate_t mbs1,mbs2;
+          memset(&mbs1,0,sizeof(mbs1));
+          memset(&mbs2,0,sizeof(mbs2));
+          length3 = 0;
+          while (length3 != match_size) {
+            length1 = mbrtowc(&onechar,p1,lim-p1,&mbs1);
+            p1+=length1;
+            length2 = wcrtomb((char *)&p2,towlower((wint_t)onechar),&mbs2);
+            length3 += length2;
+            endp = endp + length1 - length2;
+          }
+        }
+      }
+      /* MEOLIC: END OF FIX */
+#endif /* MBS_SUPPORT */
+
       /* Avoid matching the empty line at the end of the buffer. */
       if (b == lim)
         break;
",1,1,Developer Fix,N/A,,
grep.7aa698d3 ,ZWM2ODBmOG,grep/src/search.c:384-392,grep/src/grep.c:926,grep/src/search.c:557,grep/src/grep.c:1085,,"On case insensitive search, program lowering case of input string (grep/src/search.c:384-392). Length of pattern found is returned as match_size (grep/src/search.c:557). This value used to calculate length of buffer to print (grep/src/grep.c:1085). Program prints out such number of bytes (grep/src/grep.c:926). Lowering case of some unicode characters make them single-byte. So match_size is regarding to length of lowered case string, it not always be equal to length of source line which have to be printed out. That is why output string may contain different number of characters than input string has.","diff --git a/src/grep.c b/src/grep.c
index 2dc3ee9..a3ed458 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1059,7 +1059,10 @@ static EXECUTE_RET do_execute EXECUTE_ARGS
 
       result = execute (line_buf, line_next - line_buf, match_size, start_ptr);
       if (result != (size_t) -1)
-        return (line_buf - buf) + result;
+        {
+          *match_size = line_next - line_buf;
+          return (line_buf - buf) + result;
+        }
     }
 
   return (size_t) -1;",1,0,Regression,Only match should be printed,,
grep.7aa698d3 ,OWMzNDk3N2,search.c:388-388,search.c:391-391,search.c:555-555,,,"In region 1 we create new string with lower case, in 2 region we override pointer to origin string. And in 3 region we count length of origin sting in terms of new lower case string. But when we move from upper to lower case size of chars and size of string would be changed, so we can not do it like in region #3.",I could not fix this bug,N/A,N/A,N/A,N/A,,
grep.7aa698d3 ,NTM3Y2E1MW,src/grep.c:2240-2242,src/searh.c:387-388,src/searchutils.c:60-113,,,The problem I figured was in the mbtolower() function. mbtolower adds a NUL byte at the end. I am guessing this must be the problem.,"--- search.c    2016-06-13 12:39:30.139747010 +0530
+++ search_copy.c   2016-06-13 12:40:04.447748647 +0530
@@ -385,7 +385,9 @@
         {
           /* mbtolower adds a NUL byte at the end.  That will provide
         space for the sentinel byte dfaexec may add.  */
-          char *case_buf = mbtolower (buf, &size);
+          char *case_buf = xmalloc(size);
+          memcpy(case_buf, buf, size);
+
      if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
           buf = case_buf;",1,0,Regression,Case-sensitve search when it should be case-insensitive,,
grep.7aa698d3 ,ZmU3ZTExOW,src/search.c:94,src/search.c:119,src/grep.c:2004,,,wrong use of condition. coder has assumed only cases to go in if condition but user can enter anything so if condition was not put properly.,"diff --git a/src/search.c b/src/search.c
index 1c9272e..b570616 100644
--- a/src/search.c
+++ b/src/search.c
@@ -116,7 +116,7 @@ mbtolower (const char *beg, size_t *n)
           p = out + outlen;
         }

-      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
+      if (mbclen == (size_t) -1 || mbclen <= (size_t) -2 || mbclen == 0)
         {
           /* An invalid sequence, or a truncated multi-octet character.
              We treat it as a single-octet character.  */
",1,0,Regression,Always fail to match multibyte characters,,
grep.7aa698d3 ,MjYyYzZkN2,src/grep.c:1091,src/grep.c:1060,src/search.c:388,,,"When printing matching line (region 1), the length of string to be printed is determined by function execute (region 2), which, in this case, transforms string to lower case using mbtolower (region 3) thus losing information about bizzare characters which occupy different memory sizes in lower case and upper case.","diff --git a/src/search.c b/src/search.c
index 1c9272e..a4cedf5 100644
--- a/src/search.c
+++ b/src/search.c
@@ -372,20 +372,22 @@ COMPILE_FCT(Ecompile)
 
 EXECUTE_FCT(EGexecute)
 {
-  register char const *buflim, *beg, *end, *match, *best_match;
+  register char const *buflim, *beg, *end, *match, *best_match, *ptr;
   char eol = eolbyte;
   int backref, start, len, best_len;
   struct kwsmatch kwsm;
   size_t i, ret_val;
 #ifdef MBS_SUPPORT
-  char *mb_properties = NULL;
+  char *mb_properties = NULL, *orig_mb_properties = NULL;
   if (MB_CUR_MAX > 1)
     {
       if (match_icase)
         {
           /* mbtolower adds a NUL byte at the end.  That will provide
              space for the sentinel byte dfaexec may add.  */
-          char *case_buf = mbtolower (buf, &size);
+          char *case_buf;
+          orig_mb_properties = check_multibyte_string(buf, size);
+          case_buf = mbtolower (buf, &size);
           if (start_ptr)
             start_ptr = case_buf + (start_ptr - buf);
           buf = case_buf;
@@ -553,6 +555,13 @@ EXECUTE_FCT(EGexecute)
 
  success:
   len = end - beg;
+  if (orig_mb_properties)
+  {
+    for (ptr = beg; ptr < end; ptr++)
+      len += orig_mb_properties[ptr-beg];
+    len--;  /* deal with zero terminator */
+  }
+
  success_in_len:
   *match_size = len;
   ret_val = beg - buf;
",1,0,Incomplete Fix,Not all lower-cases of multibyte characters occupy one byte less.,,
grep.8f08d8e2 ,OWUwOTY1N2,src/search.c:397-399,src/search.c:408-417,src/grep.c:1007,src/grep.c:997,,"EGexecute function was returning the pattern match itself, instead of the line containing that match","diff --git a/src/search.c b/src/search.c
index 206260d..75c4069 100644
--- a/src/search.c
+++ b/src/search.c
@@ -410,8 +410,11 @@ EXECUTE_FCT(EGexecute)
                   {
                     if ((match == buf || !WCHAR ((unsigned char) match[-1]))
                         && (len == end - beg - 1
-                            || !WCHAR ((unsigned char) match[len])))
+                            || !WCHAR ((unsigned char) match[len]))) {
+                      match = beg;
+                      len = end - beg;
                       goto assess_pattern_match;
+                    }
                     if (len > 0)
                       {
                         /* Try a shorter length anchored at the same place. */
",1,1,Different but Correct,N/A,,
grep.8f08d8e2 ,YmI4MGM3ND,src/grep.c:997-998,src/search.c:388-400,src/search.c:388-446,,,"probably cause of error is that ""execute"" function in src/grep.c:997-998 returns match_size equals to only two first words, but I couldn't find where exact line with error code, probably related to regex parser","diff --git a/src/search.c b/src/search.c
index 206260d..c660321 100644
--- a/src/search.c
+++ b/src/search.c
@@ -445,7 +445,7 @@ EXECUTE_FCT(EGexecute)
                  /* Good enough for a non-exact match.
                     No need to look at further patterns, if any.  */
                  beg = match;
-                 goto success_in_len;
+                 goto success;
                }
              if (match < best_match || (match == best_match && len > best_len))
                {
",1,1,Developer Fix,N/A,,
grep.8f08d8e2 ,MjYyZjkxNm,src/grep.c:990-1034,src/grep.c:920-978,src/grep.c:862-890,src/search.c:300-488,,"At section 1 we use an incorrect value for line limit value and this is then wrongly used at sections 2 and 3, printing an invalid line value (truncated).
This line limit is wrongly calculated at section 4 when doing regex match","diff --git a/src/search.c b/src/search.c
index 206260d..eb2e1ba 100644
--- a/src/search.c
+++ b/src/search.c
@@ -472,6 +472,7 @@ EXECUTE_FCT(EGexecute)
  success:
   len = end - beg;
  success_in_len:
+  len = end - beg;
   *match_size = len;
   ret_val = beg - buf;
  out:",1,0,Regression,Also affects regex patterns (see search.c:463),,
grep.8f08d8e2 ,ZGU4Yjc1ZG,src/grep.c:997-998,src/grep.c:1007,src/search.c:411-414,,,"For -w function execute() when called at src/grep.c:997-998 returns the size of recognized pattern and not the whole line. Therefore, only a part of the line is printed out at src/grep.c:1007. The root cause of the error is in the block at src/search.c:411-414, where the program checks if the pattern was found. In the case of success the part of the program labelled with ""assess_pattern_match"" can be executed. During the test at src/search.c:411-414, variable len keeps the size of the pattern because it must be checked if after the pattern there are correct characters. Butif the pattern is confirmed then the whole line is confirmed and thus variable len should be changed to contain the length of the whole line.  This is missing.","diff --git a/src/search.c b/src/search.c
index 206260d..6ee74aa 100644
--- a/src/search.c
+++ b/src/search.c
@@ -411,7 +411,10 @@ EXECUTE_FCT(EGexecute)
                     if ((match == buf || !WCHAR ((unsigned char) match[-1]))
                         && (len == end - beg - 1
                             || !WCHAR ((unsigned char) match[len])))
+                        {
+              len = end - beg; /* MEOLIC: BUG FIXING */
                       goto assess_pattern_match;
+                    }
                     if (len > 0)
                       {
                         /* Try a shorter length anchored at the same place. */
",1,1,Different but Correct,N/A,,
grep.8f08d8e2 ,ZWM2ODBmOG,grep/src/search.c:448,grep/src/grep.c:882,grep/src/search.c:388,,,Variable 'len' assigned value of regexp match length (grep/src/search.c:388). This value is returned as found match length (grep/src/search.c:448) and used to print out amount of bytes (grep/src/grep.c:882) instead of actual line length. ,"diff --git a/src/search.c b/src/search.c
index 206260d..c660321 100644
--- a/src/search.c
+++ b/src/search.c
@@ -445,7 +445,7 @@ EXECUTE_FCT(EGexecute)
                   /* Good enough for a non-exact match.
                      No need to look at further patterns, if any.  */
                   beg = match;
-                  goto success_in_len;
+                  goto success;
                 }
               if (match < best_match || (match == best_match && len > best_len))
                 {",1,1,Developer Fix,N/A,,
grep.8f08d8e2 ,ZmU3ZTExOW,src/grep.c:866,src/grep.c:976,src/grep.c:1116,,,"according to me,correct length was not passed to print so though string was there but we were not printing it as we passed wrong length.","diff --git a/src/grep.c b/src/grep.c
index 28ae71b..ec46d71 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -879,7 +879,7 @@ prline (char const *beg, char const *lim, int sep)
     }

   if (!only_matching && lim > beg)
-    fwrite (beg, 1, lim - beg, stdout);
+    fwrite (beg, 1, lim - beg + strlen(lim), stdout);

   if (ferror (stdout))
     error (0, errno, _(""writing output""));
",1,0,Regression,N/A,,
grep.8f08d8e2 ,MDUyYzIwMz,search.c:408-452,grep.c:997-1034,grep.c:918-982,grep.c:707-858,,"bad readability of code leading to oversights from the programmer.
","diff --git a/src/search.c b/src/search.c
index 206260d..dbfff74 100644
--- a/src/search.c
+++ b/src/search.c
@@ -445,7 +445,11 @@ EXECUTE_FCT(EGexecute)
                   /* Good enough for a non-exact match.
                      No need to look at further patterns, if any.  */
                   beg = match;
-                  goto success_in_len;
+      if (!match_words)
+        goto success_in_len;
+      else
+        goto success;
+
                 }
               if (match < best_match || (match == best_match && len > best_len))
                 {

",1,1,Developer Fix,N/A,,
grep.8f08d8e2 ,MGFkYmExOT,src/search.c:408,src/search.c:414,src/search.c:448,src/search.c:388,src/search.c:398,"When grep finds a match it finally checks for the word boundaries here src/search.c:408. Because there is no special things in our string it takes goto here src/search.c:414, and another goto here src/search.c:448. By this time `len` is 7 as it was at src/search.c:388. So returned match is a sub-string of the whole string. (i.e. ret_val and match_size). And later only this sub-string is printed.
","diff --git a/src/search.c b/src/search.c
index 206260d..c660321 100644
--- a/src/search.c
+++ b/src/search.c
@@ -445,7 +445,7 @@ EXECUTE_FCT(EGexecute)
                  /* Good enough for a non-exact match.
                     No need to look at further patterns, if any.  */
                  beg = match;
-                 goto success_in_len;
+                 goto success;
                }
              if (match < best_match || (match == best_match && len > best_len))
                {
",1,1,Developer Fix,N/A,,
grep.9c45c193,OWUwOTY1N2,lib/exclude.c:359,src/grep.c:2268,lib/exclude.c:410,lib/exclude.c:426,,EXCLUDE_INCLUDE flag is accounted twice in both excluded_file_name and excluded_file_pattern_p functions.,"in lib/exclude.c:359 replace line:

  bool excluded = !! (options & EXCLUDE_INCLUDE);

with:

  bool excluded = 0;
",0,0,Unrelated Workaround,The bug is definitely not in the third-party library.,,
grep.9c45c193,YmI4MGM3ND,src/grep.c:2136-2140,lib/exclude.c:445,src/grep.c:2261-2286,,,"""include"" option skipped by the incorrect loop within main function src/grep.c:2267+","diff --git a/src/grep.c b/src/grep.c
index fbeb089..8cbed5c 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2265,8 +2265,10 @@ There is NO WARRANTY, to the extent permitted by law.\n""),
              && !isdir (file))
            {
              if (included_patterns &&
-                 ! excluded_file_name (included_patterns, file))
-               continue;
+                 ! excluded_file_name (included_patterns, file)) {
+                 status &= grepfile (file, &stats_base);
+                 continue;
+             }
              if (excluded_patterns &&
                  excluded_file_name (excluded_patterns, file))
                continue;
",1,0,Incomplete Fix,Doesn't skip files that are *not* in the included patterns.,,
grep.9c45c193,MjYyZjkxNm,src/grep.c:1866-1871,src/grep.c:2136-2140,src/grep.c:2260-2283,,,"Files put at --include-dir are never treated by the program.

After picking correctly the files to be included at section 2, we never process them at section 3. The logic there is broken and we skip the file processing.","diff --git a/src/grep.c b/src/grep.c
index fbeb089..82373af 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2264,8 +2264,7 @@ There is NO WARRANTY, to the extent permitted by law.\n""),
          if ((included_patterns || excluded_patterns)
              && !isdir (file))
            {
-             if (included_patterns &&
-                 ! excluded_file_name (included_patterns, file))
+             if (included_patterns &&  excluded_file_name (included_patterns, file))
                continue;
              if (excluded_patterns &&
                  excluded_file_name (excluded_patterns, file))",1,1,Developer Fix,N/A,,
grep.9c45c193,ZGU4Yjc1ZG,src/grep.c:2136-2140,src/grep.c:2267-2269,src/grep.c:2274,,,"For --include, an internal structure included_patterns is built. This happens at src/grep.c:2136-2140. In the original program, this internal structure is not correctly builded (e.g. for patterns there will be an entry intended for hashes). Thus the decision at src/grep.c:2267-2269 is not correctly classifying files and thus wrong files are evaluated at src/grep.c:2274.","diff --git a/src/grep.c b/src/grep.c
index fbeb089..b571a61 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
         if (!included_patterns)
           included_patterns = new_exclude ();
-        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+        add_exclude (included_patterns, optarg, EXCLUDE_WILDCARDS); /* MEOLIC: BUG FIXING */
         break;
 
 
",1,1,Different but Correct,Effectively negates the faulty condition,,
grep.9c45c193,ZWM2ODBmOG,grep/src/grep.c:2267-2269,grep/lib/exclude.c:399-440,grep/lib/exclude.c:355-394,,,"If --include command line option used, program invokes excluded_file_name() function to look for file name in hash table using excluded_file_name_p() (grep/lib/exclude.c:355-394) function invoked through excluded_file_name()  (grep/lib/exclude.c:399-440)call. The same code used for both --include and exclude options but each function returns 'false' on file occurrence when EXCLUDE_INCLUDE option passed and 'true' on another case. But code (grep/src/grep.c:2267-2269) skips the file when 'false' returned. It lets file to check on 'true' return value. So --include option works just the same as --exclude by that way. ","diff --git a/src/grep.c b/src/grep.c
index fbeb089..8460e8a 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2265,7 +2265,7 @@ There is NO WARRANTY, to the extent permitted by law.\n""),
               && !isdir (file))
             {
               if (included_patterns &&
-                  ! excluded_file_name (included_patterns, file))
+                  excluded_file_name (included_patterns, file))
                 continue;
               if (excluded_patterns &&
                   excluded_file_name (excluded_patterns, file))",1,1,Developer Fix,N/A,,
grep.9c45c193,OWMzNDk3N2,src/grep.c:2267-2269,src/grep.c:2270-2272,src/grep.c:2274-2275,,,Wrong condition in first region,"diff --git a/src/grep.c b/src/grep.c
index fbeb089..8460e8a 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2265,7 +2265,7 @@ There is NO WARRANTY, to the extent permitted by law.\n""),
               && !isdir (file))
             {
               if (included_patterns &&
-                  ! excluded_file_name (included_patterns, file))
+                  excluded_file_name (included_patterns, file))
                 continue;
               if (excluded_patterns &&
                   excluded_file_name (excluded_patterns, file))
",1,1,Developer Fix,N/A,,
grep.9c45c193,ZjZhNTVkNj,grep/lib/exclude.c:410,grep/lib/exclude.c:359,grep/lib/exclude.c:338,,,The conditional statement needed to be negated. ,"diff --git a/src/grep.c b/src/grep.c
index fbeb089..8460e8a 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2265,7 +2265,7 @@ There is NO WARRANTY, to the extent permitted by law.\n""),
              && !isdir (file))
            {
              if (included_patterns &&
-                 ! excluded_file_name (included_patterns, file))
+                 excluded_file_name (included_patterns, file))
                continue;
              if (excluded_patterns &&
                  excluded_file_name (excluded_patterns, file))",1,1,Developer Fix,N/A,,
grep.9c45c193,NTM3Y2E1MW,src/grep.c:2136-2140,src/grep.c:2262-2276,lib/exclude.c:400-440,,,The program was excluding the file from its searches since there was a not (!) in front of the excluded_file_name(),"--- grep.c  2017-06-03 15:29:45.579328704 +0530
+++ grep_new.c  2016-06-03 15:30:18.691330283 +0530
@@ -2265,7 +2265,7 @@
          && !isdir (file))
        {
          if (included_patterns  &&
-         !excluded_file_name (included_patterns, file))
+         excluded_file_name (included_patterns, file))
        continue;
          if (excluded_patterns &&
          excluded_file_name (excluded_patterns, file))                                                          ",1,1,Developer Fix,N/A,,
grep.9c45c193,MDliMzQ4OT,src/grep.c:2268,gnulib/lib/exclude.c:399,gnulib/lib/exclude.c:359,,,The call to check whether file is included (region 1) was incorrectly logically inverted. The function performing the check (region 2) does in turn all the necessary logical negations itself (region 3).,"diff --git a/src/grep.c b/src/grep.c
index fbeb089..8460e8a 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2265,7 +2265,7 @@ There is NO WARRANTY, to the extent permitted by law.\n""),
               && !isdir (file))
             {
               if (included_patterns &&
-                  ! excluded_file_name (included_patterns, file))
+                  excluded_file_name (included_patterns, file))
                 continue;
               if (excluded_patterns &&
                   excluded_file_name (excluded_patterns, file))
",1,1,Developer Fix,N/A,,
grep.9c45c193,ZmU3ZTExOW,find/grep.c:2267,find/search.c:188,find/grep.c:2139,,,wrong handling of if condition. include argument should be considered and processed but here because of wrong if condition it was just continuing without processing it.,"diff --git a/src/grep.c b/src/grep.c
index fbeb089..4081243 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2264,8 +2264,7 @@ There is NO WARRANTY, to the extent permitted by law.\n""),
          if ((included_patterns || excluded_patterns)
              && !isdir (file))
            {
-             if (included_patterns &&
-                 ! excluded_file_name (included_patterns, file))
+             if (included_patterns && excluded_file_name (included_patterns, file))
                continue;
              if (excluded_patterns &&
                  excluded_file_name (excluded_patterns, file))",1,1,Developer Fix,N/A,,
grep.9c45c193,MGFkYmExOT,grep.c:2268,exclude.c:409,exclude.c:426,,,At grep.c:2268 the included file is incorrectly skipped. The function excluded_file_name() returns if the file should be skipped. Literally. So there is no need to invert it's result.,"diff --git a/src/grep.c b/src/grep.c
index fbeb089..8460e8a 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2265,7 +2265,7 @@ There is NO WARRANTY, to the extent permitted by law.\n""),
              && !isdir (file))
            {
              if (included_patterns &&
-                 ! excluded_file_name (included_patterns, file))
+                 excluded_file_name (included_patterns, file))
                continue;
              if (excluded_patterns &&
                  excluded_file_name (excluded_patterns, file))
",1,1,Developer Fix,N/A,,
grep.9c45c193,MDUyYzIwMz,grep.c:2139,grep.c:2263-2275,noother.c:0,,,the included_pattern is used in the same way as the excluded_pattern except a negation. Thus it should have the same flags,"diff --git a/src/grep.c b/src/grep.c
index fbeb089..05df4dc 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -2136,7 +2136,7 @@ main (int argc, char **argv)
       case INCLUDE_OPTION:
         if (!included_patterns)
           included_patterns = new_exclude ();
-        add_exclude (included_patterns, optarg, EXCLUDE_INCLUDE);
+        add_exclude (included_patterns, optarg, EXCLUDE_WILDCARDS);
         break;
 
 
",1,1,Different but Correct,Effectively negates the faulty condition,,
grep.c1cb19fe ,YmI4MGM3ND,src/search.c:378,src/dfa.c:2893-2896,src/dfa.c:1982-2272,,,"I couldn't understand root cause (in terms of few lines of code, hard to understand logic in ~300 lines function), but ""trans"" array filled in different ways for LC_ALL=C and LC_ALL=ru_RU.koi8r",coulnd't fix the error,N/A,N/A,N/A,N/A,,
grep.c1cb19fe ,ZGU4Yjc1ZG,src/dfa.c:1418,src/dfa.c:1103-1117,src/dfa.c:472,,,"For some locale, variable hard_LC_COLLATE is set (see src/dfa.c:1418) to denote that letters are ordered in a strange way (e.g. Russian cyrilic). In this case, else part of the block at src/dfa.c:1103-1117 is used to prepare the info about the letters in the given range. Function in_coll_range() uses the correct function strcoll() to compare letters. But the condition at src/dfa.c:472 has an error and thus wrong letters are selected to be in the given range.","diff --git a/src/dfa.c b/src/dfa.c
index 3122e22..b218c57 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -469,7 +469,7 @@ static int
 in_coll_range (char ch, char from, char to)
 {
   char c[6] = { from, 0, ch, 0, to, 0 };
-  return strcoll (&c[0], &c[2]) <= 0 && 0 <= strcoll (&c[2], &c[4]);
+  return strcoll (&c[0], &c[2]) <= 0 && strcoll (&c[2], &c[4]) <= 0; /* MEOLIC: BUG FIXING */
 }
 
 #ifdef MBS_SUPPORT
",1,1,Developer Fix,N/A,,
grep.c1cb19fe ,ZWM2ODBmOG,grep/src/dfa.c:1113-1116,grep/src/dfa.c:469-473,grep/src/dfa.c:319-329,,,Program sets bit flag for each character (grep/src/dfa.c:319-329) if the character is within user defined range (grep/src/dfa.c:1113-1116). For locale dependent comparison strcoll() function used (grep/src/dfa.c:469-473). Function in_coll_range() incorrectly determined if a character is within a range.,"diff --git a/src/dfa.c b/src/dfa.c
index 3122e22..f695625 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -469,7 +469,7 @@ static int
 in_coll_range (char ch, char from, char to)
 {
   char c[6] = { from, 0, ch, 0, to, 0 };
-  return strcoll (&c[0], &c[2]) <= 0 && 0 <= strcoll (&c[2], &c[4]);
+  return strcoll (&c[0], &c[2]) <= 0 && 0 >= strcoll (&c[2], &c[4]);
 }
 
 #ifdef MBS_SUPPORT",1,1,Developer Fix,N/A,,
grep.c1cb19fe ,OWMzNDk3N2,dfa.c:469-473,dfa.c:472-472,dfa.c:471-471,,,Wrong condition in region #2,"diff --git a/src/dfa.c b/src/dfa.c
index 3122e22..61154af 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -469,7 +469,7 @@ static int
 in_coll_range (char ch, char from, char to)
 {
   char c[6] = { from, 0, ch, 0, to, 0 };
-  return strcoll (&c[0], &c[2]) <= 0 && 0 <= strcoll (&c[2], &c[4]);
+  return strcoll (&c[0], &c[2]) <= 0 && 0 <= strcoll (&c[4], &c[2]);
 }
 
 #ifdef MBS_SUPPORT
",1,1,Developer Fix,N/A,,
grep.c1cb19fe ,NTM3Y2E1MW,src/grep.c:1879-1881,src/grep.c:2299-2301,src/grep.c:1290-1292,src/grep.c:1201-1203,,"The LC_ALL was being set to the environment variable since it was """"(an empty string).And since the LC_ALL env was being set to  ru_RU.KOI8-R, it wasn't printing 'f'","--- grep.c  2016-06-03 22:13:02.178251717 +0530
+++ grep_copy.c 2016-06-03 22:16:07.154260542 +0530
@@ -1877,7 +1877,7 @@

   /* Internationalization. */
 #if defined(HAVE_SETLOCALE)
-  setlocale (LC_ALL, """");
+  setlocale (LC_ALL, ""C"");
 #endif
 #if defined(ENABLE_NLS)
   bindtextdomain (PACKAGE, LOCALEDIR);",1,0,Incorrect Workaround,LC_ALL is supposed to be changable,,
grep.c1cb19fe ,MjYyYzZkN2,src/dfa.c:472,src/dfa.c:1115,src/dfa.c:319,,,"The function to fill character class corresponding to [] pattern (region 1) was using strcoll, which is locale-dependent - that was screwing english characters (the first half of ASCII table, to be precise).","diff --git a/src/dfa.c b/src/dfa.c
index 3122e22..c88235c 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -469,6 +469,8 @@ static int
 in_coll_range (char ch, char from, char to)
 {
   char c[6] = { from, 0, ch, 0, to, 0 };
+  if (ch < 128)
+    return from <= ch && ch <= to;
   return strcoll (&c[0], &c[2]) <= 0 && 0 <= strcoll (&c[2], &c[4]);
 }
 ",1,0,Incorrect Workaround,Comparison is supposed to be locale-dependent (strcoll),,
grep.c1cb19fe ,MDUyYzIwMz,dfa.c:473,dfa.c:1100-1121,noother.c:0,,,The compare operations for characters is wrong.,"diff --git a/src/dfa.c b/src/dfa.c
index 3122e22..77766ac 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -468,8 +468,9 @@ fetch_wc (char const *eoferr)
 static int
 in_coll_range (char ch, char from, char to)
 {
+  assert(from <= to);
   char c[6] = { from, 0, ch, 0, to, 0 };
-  return strcoll (&c[0], &c[2]) <= 0 && 0 <= strcoll (&c[2], &c[4]);
+  return strcoll (&c[0], &c[2]) <= 0 && strcoll (&c[2], &c[4]) <= 0;
 }
 
 #ifdef MBS_SUPPORT
",1,1,Developer Fix,N/A,,
grep.c1cb19fe ,MGFkYmExOT,src/dfa.c:469,none.c:0,none.c:0,,,"strcoll() in in_coll_range() src/dfa.c:469 used incorrectly, causing all characters fail to pass the check against a range.","diff --git a/src/dfa.c b/src/dfa.c
index 3122e22..9e9f369 100644
--- a/src/dfa.c
+++ b/src/dfa.c
@@ -469,7 +469,7 @@ static int
 in_coll_range (char ch, char from, char to)
 {
   char c[6] = { from, 0, ch, 0, to, 0 };
-  return strcoll (&c[0], &c[2]) <= 0 && 0 <= strcoll (&c[2], &c[4]);
+  return strcoll (&c[2], &c[0]) >= 0 && strcoll (&c[2], &c[4]) <= 0;
 }
 
 #ifdef MBS_SUPPORT
",1,1,Developer Fix,N/A,,
grep.c96b0f2c ,OWUwOTY1N2,src/grep.c:1081,src/grep.c:1091,src/grep.c:1060,src/search.c:386-387,src/grep.c:898,"dfaexec function with pattern '^$' returns empty match at the beginning of non-empty strings, while it should not.","diff --git a/src/grep.c b/src/grep.c
index e289095..478768e 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1088,7 +1088,9 @@ grepbuf (char const *beg, char const *lim)
        break;
       if (!out_invert)
        {
-         prtext (b, endp, (int *) 0);
+          if (b < endp) {
+            prtext (b, endp, (int *) 0);
+          }
          nlines++;
           outleft--;
          if (!outleft || done_on_match)
",0,0,Incomplete Fix,Test case still failing,,
grep.c96b0f2c ,YmI4MGM3ND,src/grep.c:1081-1121,src/grep.c:1045-1065,src/search.c:326-522,,,"Code within src/grep.c:1045-1065, while loop doesn't check if any string matched, but prints result; error doesn't happened with ""C"" locale because ""do_execute"" goes in different branch, searches in whole input buffer and always returns  non zero ""match_size""","diff --git a/src/grep.c b/src/grep.c
index e289095..062eb9a 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1086,6 +1086,9 @@ grepbuf (char const *beg, char const *lim)
       /* Avoid matching the empty line at the end of the buffer. */
       if (b == lim)
        break;
+      if (!match_size) {
+         p = endp; continue;
+      }
       if (!out_invert)
        {
          prtext (b, endp, (int *) 0);
",1,0,Regression,It should not skip printing if in inversion-mode (-v),,
grep.c96b0f2c ,ZGU4Yjc1ZG,src/grep.c:1045,src/grep.c:1087-1088,src/grep.c:1091-1092,,,"If UTF8 mode is set then variable MB_CUR_MAX != 1. Threfore, function do_execute() proceeds diferently, see src/grep.c:1045. Without UTF8 mode, the whole input buffer is consumed at once but for UTF8 mode, input is consumed line by line. In the first case, checking for the end of the buffer after the call to do_execute, see src/grep.c:1087-1088, is always successful. In the second case, the function proceeds further but it is wrong, that this automaticaly means a matched line. Variable match_size must be checked before calling prtext() and incrementing the number of recognized lines, see src/grep.c:1091-1092.","diff --git a/src/grep.c b/src/grep.c
index e289095..434707f 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1088,8 +1088,12 @@ grepbuf (char const *beg, char const *lim)
         break;
       if (!out_invert)
         {
-          prtext (b, endp, (int *) 0);
-          nlines++;
+      /* MEOLIC: BUG FIXING */
+      if (match_size) {
+              prtext (b, endp, (int *) 0);
+            nlines++;
+          }
+      /* MEOLIC END OF FIX */
           outleft--;
           if (!outleft || done_on_match)
             {
",1,1,Different but Correct,N/A,,
grep.c96b0f2c ,ZWM2ODBmOG,grep/src/grep.c:1048-1063,grep/src/grep.c:1081,grep/src/grep.c:1087,,,"Program invokes do_execute() function for search a match (grep/src/grep.c:1081). For C locale this function searches in whole buffer but for unicode locales it breaks text into a lines and looking for match in each line separately (grep/src/grep.c:1048-1063). That is why do_execute() function not returns once if whole text contains no match but reporting each line of input text. Due there is no test for unmatched line, -n command line option prints out line number for each line for unicode locale. 8bit locales returns once and leaves loop immediately (grep/src/grep.c:1087).","diff --git a/src/grep.c b/src/grep.c
index e289095..6c6feae 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1086,6 +1086,11 @@ grepbuf (char const *beg, char const *lim)
       /* Avoid matching the empty line at the end of the buffer. */
       if (b == lim)
         break;
+      if (!out_invert && !match_size)
+        {
+          p = endp;
+          continue;
+        }
       if (!out_invert)
         {
           prtext (b, endp, (int *) 0);",1,1,Different but Correct,N/A,,
grep.c96b0f2c ,OWMzNDk3N2,search.c:386-387,search.c:388-388,search.c:354-501,,,Incomplete condition in range #2.,"diff --git a/src/search.c b/src/search.c
index d9b4462..38b929f 100644
--- a/src/search.c
+++ b/src/search.c
@@ -385,7 +385,7 @@ EXECUTE_FCT(EGexecute)
               /* No good fixed strings; start with DFA. */
               char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
                                               0, NULL, &backref);
-              if (next_beg == NULL)
+              if (next_beg == NULL || next_beg == buflim)
                 break;
               /* Narrow down to the line we've found. */
               beg = next_beg;
",1,1,Developer Fix,N/A,,
grep.c96b0f2c ,NTM3Y2E1MW,src/search.c:323-522,src/dfa.c:2748-2920,src/grep.c:2297-2299,src/grep.c:2308-2309,,A check in the error condition was missing. The code to check if we have matched the sentinel is missing. Phew! Took a lot of amount to detect.,"--- search.c    2016-06-12 16:38:53.788006757 +0530
+++ search_copy.c   2016-06-12 16:40:05.932010198 +0530
@@ -385,7 +385,7 @@
          /* No good fixed strings; start with DFA. */
          char const *next_beg = dfaexec (&dfa, beg, (char *) buflim,
                          0, NULL, &backref);
-         if (next_beg == NULL)
+         if (next_beg == NULL || next_beg == buflim)
        break;
          /* Narrow down to the line we've found. */
          beg = next_beg;",1,1,Developer Fix,N/A,,
grep.c96b0f2c ,MjYyYzZkN2,src/grep.c:1060,src/search.c:386,src/dfa.c:2728,,,The hack for multibyte multiline search strings (explained in the comment above region 1) was written wrong: it had off-by-one error in length. So the wrong search string was propagated further (regions 2 and 3).,"diff --git a/src/grep.c b/src/grep.c
index e289095..01e27fb 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1057,7 +1057,7 @@ static EXECUTE_RET do_execute EXECUTE_ARGS
       if (start_ptr && start_ptr >= line_end)
         continue;
 
-      result = execute (line_buf, line_next - line_buf, match_size, start_ptr);
+      result = execute (line_buf, line_next - line_buf - 1, match_size, start_ptr);
       if (result != (size_t) -1)
         return (line_buf - buf) + result;
     }
",1,0,Regression,string length is already calculated correctly,,
grep.c96b0f2c ,ZmU3ZTExOW,src/grep.c:1860,src/grep.c:1062,src/dfa.c:2212,,,Invalid sequence was handled in wrong way. If invalid sequence program should just quit.,"diff --git a/src/grep.c b/src/grep.c
index e289095..c154ebd 100644
--- a/src/grep.c
+++ b/src/grep.c
@@ -1860,11 +1860,14 @@ mb_icase_keys (char **keys, size_t *len)
          lj += mcm;
          kj = xrealloc(kj, lj + 1);
        }
-      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
+      if (mbclen == (size_t) -1 || mbclen <= (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
-         kj[j++] = ki[i++];
+          if(mbclen <= (size_t) -2)
+            exit(1);
+          else
+            kj[j++] = ki[i++];
        }
       else
        {
",1,0,Regression,Quite if there exist multibyte characters,,
grep.db9d6340,OWUwOTY1N2,src/search.c:638-642,src/search.c:644,src/search.c:632,,,"When pattern was matched in the middle of multibyte character, the searching was reset to start over from the beginning of the buffer","diff --git a/src/search.c b/src/search.c
index c986d48..dabb933 100644
--- a/src/search.c
+++ b/src/search.c
@@ -634,14 +634,11 @@ EXECUTE_FCT(Fexecute)
       size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
       if (offset == (size_t) -1)
        goto failure;
+      beg += offset;
 #ifdef MBS_SUPPORT
-      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
-        {
-          beg = mb_start - 1;
-          continue; /* It is a part of multibyte character.  */
-        }
+      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg, buf + size))
+        continue; /* It is a part of multibyte character.  */
 #endif /* MBS_SUPPORT */
-      beg += offset;
       len = kwsmatch.size[0];
       if (start_ptr && !match_words)
        goto success_in_beg_and_len;
",1,0,Regression,treating the symptom but also affecting other inputs,,
grep.db9d6340,MjYyZjkxNm,src/grep.c:1073-1118,src/grep.c:1028-1066,src/search.c:613-695,,,Infinite loop because control variables are modified outside the for statement,"diff --git a/src/search.c b/src/search.c
index c986d48..c35729a 100644
--- a/src/search.c
+++ b/src/search.c
@@ -611,7 +611,7 @@ COMPILE_FCT(Fcompile)
 
 EXECUTE_FCT(Fexecute)
 {
-  char const *beg, *try, *end, *mb_start;
+  char const *beg, *try, *end, *mb_start, *pos;
   size_t len;
   char eol = eolbyte;
   struct kwsmatch kwsmatch;
@@ -629,7 +629,7 @@ EXECUTE_FCT(Fexecute)
     }
 #endif /* MBS_SUPPORT */
 
-  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
+  for (pos = mb_start = beg = start_ptr ? start_ptr : buf; pos <= buf + size; pos++)
     {
       size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
       if (offset == (size_t) -1)",1,0,Regression,treating the symptom but also affecting other inputs,,
grep.db9d6340,YmI4MGM3ND,src/search.c:632,src/search.c:638-642,src/search.c:228-256,,,"In case of multi-byte characters in matching string, loop in the Fexecute function never ends because of ""end-of-loop"" condition never evaluated to true src/search.c:638-642) (beg pointer always stays the same, not moving); this is happened because of ""beg"" pointer evaluated as base of ""mb_start"", but mb_start doesn't gen ever modified as it supposed in ""is_mb_middle"" function.","diff --git a/src/search.c b/src/search.c
index c986d48..25fc526 100644
--- a/src/search.c
+++ b/src/search.c
@@ -251,7 +251,7 @@ is_mb_middle(const char **good, const char *buf, const char *end)
       p += mbclen;
     }

-  *good = prev;
+  *good = p;
   return p > buf;
 }
 #endif /* MBS_SUPPORT */
",1,1,Different but Correct,is_mb_middle works correctly,,
grep.db9d6340,ZGU4Yjc1ZG,src/search.c:632-642,src/search.c:640,src/search.c:632,,,"For -F, checking for patterns is executed in kwsexec() called from the loop at src/search.c:632-642. Function kwsexec() returns the offset and the size of the match, offset = -1 means no match. If the match is part of a multibyte character then this it is an invalid match (the whole character should be matched). Thus, at src/search.c:640 the program tries to skip it considering the definition of the loop at src/search.c:632 which has beg++. However, line at src/search.c:640 is wrong and it does not succesfuly skip the invalid match.","iff --git a/src/search.c b/src/search.c
index c986d48..f92e036 100644
--- a/src/search.c
+++ b/src/search.c
@@ -637,7 +637,7 @@ EXECUTE_FCT(Fexecute)
 #ifdef MBS_SUPPORT
       if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
         {
-          beg = mb_start - 1;
+          beg += offset +  kwsmatch.size[0] - 1; /* MEOLIC: BUG FIXING */
           continue; /* It is a part of multibyte character.  */
         }
 #endif /* MBS_SUPPORT */
",1,1,Different but Correct,N/A,,
grep.db9d6340,ZWM2ODBmOG,grep/src/search.c:632,grep/src/search.c:640,grep/src/search.c:638,,,Within for() loop (grep/src/search.c:632) body its variable counter 'beg' is decreased (grep/src/search.c:640) when it points to middle of a multibyte character (grep/src/search.c:638).,"diff --git a/src/search.c b/src/search.c
index c986d48..6d19b55 100644
--- a/src/search.c
+++ b/src/search.c
@@ -636,10 +636,7 @@ EXECUTE_FCT(Fexecute)
         goto failure;
 #ifdef MBS_SUPPORT
       if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
-        {
-          beg = mb_start - 1;
           continue; /* It is a part of multibyte character.  */
-        }
 #endif /* MBS_SUPPORT */
       beg += offset;
       len = kwsmatch.size[0];",1,0,Regression,treating the symptom but also affecting other inputs,,
grep.db9d6340,OWMzNDk3N2,search.c:612-695,search.c:638-642,search.c:644-644,search.c:229-256,,"Wrong logic in main loop in region #1 (in region #2).
If is_mb_middle() function return true that we must reassign beg to mb_start, instead to mb_start - 1, and we must to delete 'continue' operator from region #2.","diff --git a/gnulib b/gnulib
--- a/gnulib
+++ b/gnulib
@@ -1 +1 @@
-Subproject commit aadf332a5c5f209affd38c35b4e9faaa8a0adecb
+Subproject commit aadf332a5c5f209affd38c35b4e9faaa8a0adecb-dirty
diff --git a/src/search.c b/src/search.c
index c986d48..03ac07a 100644
--- a/src/search.c
+++ b/src/search.c
@@ -637,11 +637,11 @@ EXECUTE_FCT(Fexecute)
 #ifdef MBS_SUPPORT
       if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
         {
-          beg = mb_start - 1;
-          continue; /* It is a part of multibyte character.  */
+          beg = mb_start;
         }
-#endif /* MBS_SUPPORT */
+#else
       beg += offset;
+#endif /* MBS_SUPPORT */
       len = kwsmatch.size[0];
       if (start_ptr && !match_words)
         goto success_in_beg_and_len;
",1,0,Treating the Symptom,N/A,,
grep.db9d6340,NTM3Y2E1MW,src/search.c:637-639,src/search.c:677-680,src/search.c:693-695,,,"The previous grep bugs helped me solve this bug quickly. I had seen through the is_mb_middle() code and the way to solve the bug.
The idea was to restrict the code in to going through an infinte loop when it searches for an incomplete non-prefix part of a multi byte char","--- search.c    2016-05-31 01:01:17.000000000 +0530
+++ search_copy.c   2016-06-13 17:56:18.090472996 +0530
@@ -635,8 +635,12 @@
       if (offset == (size_t) -1)
    goto failure;
 #ifdef MBS_SUPPORT
+      char const *s_in = mb_start;
       if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
         {
+          if (mb_start == s_in)
+            goto failure;
+
           beg = mb_start - 1;
           continue; /* It is a part of multibyte character.  */
         }
",1,1,Developer Fix,N/A,,
grep.db9d6340,MDliMzQ4OT,src/search.c:640,src/grep.c:1046,src/grep.c:1081,,,"The cause of error is when we're in the middle of string and we found multibyte character, the current string index is rewound backwards, whereas the loop goes forwards, so the loop stucks at the start of multibyte character.","diff --git a/src/search.c b/src/search.c
index c986d48..4d7db03 100644
--- a/src/search.c
+++ b/src/search.c
@@ -635,11 +635,12 @@ EXECUTE_FCT(Fexecute)
       if (offset == (size_t) -1)
         goto failure;
 #ifdef MBS_SUPPORT
-      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
-        {
-          beg = mb_start - 1;
-          continue; /* It is a part of multibyte character.  */
-        }
+      if (MB_CUR_MAX > 1)
+      {
+        while (is_mb_middle (&mb_start, beg+offset, buf+size))
+          beg++;
+        continue;
+      }
 #endif /* MBS_SUPPORT */
       beg += offset;
       len = kwsmatch.size[0];
",1,1,Different but Correct,N/A,,
grep.db9d6340,ZmU3ZTExOW,src/search.c:242,src/grep.c:1202,src/search.c:634,src/grep.c:1180,,"same as find10, handled on few case, it might come other case which should be handled. so every time it was returning same thing and nothing was progressing in for loop hence for loop went in infinite loop.","diff --git a/src/search.c b/src/search.c
index c986d48..4a2b839 100644
--- a/src/search.c
+++ b/src/search.c
@@ -242,7 +242,7 @@ is_mb_middle(const char **good, const char *buf, const char *end)
       if (mbclen != (size_t) -2)
         prev = p;

-      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
+      if (mbclen == (size_t) -1 || mbclen <= (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multibyte character.
             We treat it as a single byte character.  */",1,0,Regression,Always fail to match multibyte characters,,
grep.db9d6340,MDUyYzIwMz,search.c:639-640,noother.c:0,noother.c:0,,,resetting beg to start of string in loop,"diff --git a/src/search.c b/src/search.c
index c986d48..10e7d79 100644
--- a/src/search.c
+++ b/src/search.c
@@ -637,7 +637,6 @@ EXECUTE_FCT(Fexecute)
 #ifdef MBS_SUPPORT
       if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
         {
-          beg = mb_start - 1;
           continue; /* It is a part of multibyte character.  */
         }
 #endif /* MBS_SUPPORT */

",1,0,Regression,treating the symptom but also affecting other inputs,,
grep.db9d6340,MGFkYmExOT,src/search.c:638,src/search.c:640,src/search.c:632,,,is_mb_middle() at src/search.c:638 returns true and beg pointer reset to something like start of the character (but actually not). It then gets matched again.,"diff --git a/src/search.c b/src/search.c
index c986d48..9cd639b 100644
--- a/src/search.c
+++ b/src/search.c
@@ -226,17 +226,18 @@ kwsmusts (void)
 #ifdef MBS_SUPPORT
 
 static bool
-is_mb_middle(const char **good, const char *buf, const char *end)
+is_mb_middle(const char **good, const char *buf, const char *end, const char **next)
 {
   const char *p = *good;
   const char *prev = p;
   mbstate_t cur_state;
+  size_t mbclen = 0;
 
   /* TODO: can be optimized for UTF-8.  */
   memset(&cur_state, 0, sizeof(mbstate_t));
   while (p < buf)
     {
-      size_t mbclen = mbrlen(p, end - p, &cur_state);
+      mbclen = mbrlen(p, end - p, &cur_state);
 
       /* Store the beginning of the previous complete multibyte character.  */
       if (mbclen != (size_t) -2)
@@ -252,6 +253,8 @@ is_mb_middle(const char **good, const char *buf, const char *end)
     }
 
   *good = prev;
+  if (next != NULL)
+    *next = p; // or prev + mbclen?
   return p > buf;
 }
 #endif /* MBS_SUPPORT */
@@ -423,7 +426,7 @@ EXECUTE_FCT(EGexecute)
 #ifdef MBS_SUPPORT
                   if (mb_start < beg)
                     mb_start = beg;
-                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim))
+                  if (MB_CUR_MAX == 1 || !is_mb_middle (&mb_start, match, buflim, NULL))
 #endif
                     goto success;
                 }
@@ -635,9 +638,10 @@ EXECUTE_FCT(Fexecute)
       if (offset == (size_t) -1)
        goto failure;
 #ifdef MBS_SUPPORT
-      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
+      char *next;
+      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size, &next))
         {
-          beg = mb_start - 1;
+          beg = next;
           continue; /* It is a part of multibyte character.  */
         }
 #endif /* MBS_SUPPORT */
",1,1,Different but Correct,is_mb_middle works correctly,,